# KODA Knowledge Artifact: Algebraic Databases
# Domain: Category Theory / Databases

_manifest:
  urn: "urn:kora:cat:algebraic-databases:1.0.0"
  federation:
    visibility: internal
    license: "CC-BY-4.0"
  compatibility:
    min_consumer_version: "1.0.0"
    breaking_changes_from: null
  resolution:
    canonical_url: "file://knowledge/domains/cat/foundations/algebraic_databases.koda.yml"
    mirrors: []
  dependencies:
    requires:
      - urn: "urn:kora:kb:spec:1.0.0"
  provenance:
    created_by: "FS"
    created_at: "2025-12-05"
    last_modified_by: "FS"
    last_modified_at: "2025-12-14"
    signature: null

ID: CAT-ADB-01
Version: 1.0.0
Status: Active
Human-Creator: FS
Human-Editor: FS
Model-Collaborator: Cascade
Creation-Date: 2025-12-05
Modification-Date: 2025-12-14
Version-Notes: "Initial KODA/Spec skeleton for Algebraic Databases. Updated with missing MEAT+skeleton from sources/cat/Algebraic Databases.md."
Src:
  - "file://sources/cat/Algebraic Databases.md"
Ctx: "Notas estructuradas sobre profunctors, bimodules y proarrow equipments aplicados a bases de datos."

LLM_Parsing_Instructions:
  ID: KODA-LLM-PARSER-01
  Req: Mandatory block following Metadata.
  Prohib: Using for artifact creation or translation.
  Content: |
    BEGIN_LLM_INSTRUCTIONS
    You are an AI agent consuming a KODA artifact. Parse with absolute fidelity.

    FIDELITY: Preserve meat (essential information) and skeleton (structure: headers, IDs, lists, tables) with zero loss. Ignore fat (filler words, rhetoric, stylistic prose).

    LEXICON (expand before processing): Act->Action, Cond->Condition, Ctx->Context, Ctx_Required->Required External Reference, Ctx_Optional->Optional External Reference, Def->Definition, Ex->Example, Mssn->Mission, Obj->Objective, Proc->Process, Purp->Purpose, Ref->Reference, XRef->Cross-Artifact Reference, XRef_Required->Mandatory Cross-Artifact Reference, Req->Requirement, Res->Result, Src->Source, Prohib->Prohibition, Warn->Warning, Just->Justification, Rec->Recommendation

    REFERENCE POLICY: Ref: is internal only—must point to existing ID within THIS document. XRef/XRef_Required: are external only—must point to a URN (optionally with #ID fragment) in another artifact. External documents without specific ID use Ctx:, Ctx_Required:, or Ctx_Optional:.

    LANGUAGE POLICY: Keywords in English, content in original language. Never translate content.
    END_LLM_INSTRUCTIONS

Purp: "Registrar la estructura algebraica de bases de datos: profunctors, bimodules y proarrow equipments."
Obj: "Servir de fuente formal para CM-INTEGRATION-ENGINE y el diseño de uber-queries categóricas."

Source:
  Title: "Algebraic Databases"
  Authors: ["Patrick Schultz", "David I. Spivak", "Christina Vasilakopoulou", "Ryan Wisnesky"]
  Ctx: "Marco algebraico/categórico para bases de datos: profunctors, bimodules, proarrow equipments y uber-queries."

Related_Concepts:
  XRef:
    - "urn:kora:cat:unified-multimodel:1.0.0#UM-QUERY-AS-FUNCTOR"
  Notes: |
    - Los profunctors generalizan las queries multi-model como morfismos horizontales.
    - El proarrow equipment es el marco teórico para CM-INTEGRATION-ENGINE.
    - Uber-queries permiten composición de consultas cross-schema.

Advanced_Structures:
  - ID: PROFUNCTOR
    Def: "Profuntor M: C ⇸ D = funtor M: C^op × D → Set."
    Interpretation: "Generaliza funtores; modela relaciones entre categorías (por ejemplo, queries)."
    Use: "Describir consultas y correspondencias entre esquemas de bases de datos."

  - ID: BIMODULE
    Def: "Bimodule = profuntor estructurado en la doble categoría Data (esquemas, mapeos, módulos)."
    Components:
      Objects: "Esquemas (categorías)."
      Vertical_Morphisms: "Funtores (mapeos de esquema)."
      Horizontal_Morphisms: "Profuntores/módulos (queries)."
    Use: "Encapsular consultas como entidades composables."
    Ref: PROFUNCTOR

  - ID: PROARROW-EQUIPMENT
    Def: "Proarrow equipment = doble categoría que organiza esquemas, mapeos y profuntores."
    Structure:
      Objects: "Esquemas."
      Vertical_Morphisms: "Mapeos de esquemas (funtores)."
      Horizontal_Morphisms: "Profunctors/Bimodules (queries)."
    Use: "Servir de base para query rewriting y composición de migraciones complejas."
    Ref: BIMODULE

Uber_Queries:
  - ID: UBER-QUERY
    Def: "Uber-query = consulta expresada como profuntor composable dentro del equipment."
    Properties:
      - "Composicional: se compone vía composición de profuntores (M;N)."
      - "Con semántica precisa: evaluación mediante Γ_M."
      - "Verificable: permite pruebas algebraicas sobre la query."
    Use: "Diseñar pipelines de consultas sobre múltiples esquemas con garantías formales."
    Ref: [PROFUNCTOR, PROARROW-EQUIPMENT]

Query_Evaluation:
  - ID: GAMMA-EVALUATION
    Def: "Γ_M(I) = ∫^c M(c,−) × I(c): evalúa un profuntor M sobre una instancia I."
    Interpretation: "Aplicar una uber-query M a datos concretos I."
    Use: "Dar semántica a consultas categóricas sobre instancias."

  - ID: QUERY-COMPOSITION
    Def: "Composición de queries (M;N)(a,c) = ∫^b M(a,b) × N(b,c)."
    Use: "Construir consultas complejas a partir de bloques simples de forma algebraica."
    Ref: GAMMA-EVALUATION

Theoretical_Foundations:
  - ID: KAN-EXTENSION
    Def: "Extensión de Kan (Lan_F, Ran_F): mejor aproximación universal a extender funtores a lo largo de F."
    Types:
      - "Left Kan extension (Lan_F): generaliza Σ_F."
      - "Right Kan extension (Ran_F): generaliza Π_F."
    Use: "Modelar transformaciones complejas schema+data con propiedades universales."

  - ID: KAN-LIFT
    Def: "Kan lift: problema inverso de extensión; levantar estructuras a lo largo de un funtor."
    Condition: "Requiere usualmente que el funtor sea fully faithful para preservar semántica."
    Use: "Transformaciones multi-model y cambios de representación con garantías."

  - ID: YONEDA-EMBEDDING
    Def: "Embedding de Yoneda y: C → [C^op, Set] donde y(A) = Hom(−, A)."
    Property: "y es fully faithful: C se embebe en su categoría de presheaves."
    Interpretation: "Todo objeto se representa fielmente por sus relaciones con otros objetos."
    Use: "Fundamenta el diseño por interfaces y la representación de queries como presheaves."
    Proc: |
      1. Dado objeto A en C, construir presheaf y(A) = Hom(−, A).
      2. Para morfismo f: A→B, y(f) es transformación natural Hom(−,A)→Hom(−,B).
      3. El funtor y preserva y refleja isomorfismos: A≅B en C sii y(A)≅y(B).
      4. Usar para: representar schemas como presheaves, diseñar APIs por comportamiento.
    XRef: "urn:kora:cat:seven-sketches:1.0.0#YONEDA-LEMMA"

Paper_Metadata:
  - ID: ADB-ABSTRACT-01
    Content: "Databases have been studied category-theoretically for decades. In this work, we propose an extension of the earlier set-valued functor model to incorporate multi-sorted algebraic theories, capturing operations like comparing integers or concatenating strings. We also package schemas, instances, change-of-schema functors, and queries in a single double categorical structure called a proarrow equipment."

  - ID: ADB-CONTENTS-01
    Contents:
      - "1. Introduction"
      - "2. Profunctors and Proarrow Equipments"
      - "3. Algebraic Theories"
      - "4. Presentations and Syntax"
      - "5. Algebraic Database Schemas"
      - "6. Algebraic Database Instances"
      - "7. The Fundamental Data Migration Functors"
      - "8. The Double Category Data"
      - "9. Queries and Uber-Queries"
      - "10. Implementation"
      - "A. Componentwise Composition and Exponentiation in Data"

Profunctors_and_Equipments:
  - ID: ADB-PROFUNCTOR-DEF-01
    Def: "A profunctor M from a category C to a category D, written M: C ⇸ D, is a functor M: C^op × D -> Set."
    Remark: "Profunctors are also called correspondences or distributors, and can be viewed as bimodules or generalizations of relations."
    Ref: PROFUNCTOR

  - ID: ADB-PROFUNCTOR-COMPOSITION-01
    Def: "Composition of two profunctors M: C ⇸ D and N: D ⇸ E is given by the coend formula (M ⊗ N)(c,e) = ∫^{d∈D} M(c,d) × N(d,e)."
    Ref: QUERY-COMPOSITION

  - ID: ADB-PROFUNCTOR-MORPHISM-01
    Def: "A morphism of profunctors φ: M ⇒ N is a natural transformation M -> N respecting the left and right actions. The bicategory of small categories, profunctors, and transformations is written Prof."
    Ref: PROFUNCTOR

  - ID: ADB-PROARROW-EQUIPMENT-DEF-01
    Def: "A double category D has objects and vertical morphisms forming a category D_0, horizontal 1-cells forming a category D_1 with functors L,R: D_1 -> D_0, a unit functor U: D_0 -> D_1, and a composition ⊗: D_1 ×_{D_0} D_1 -> D_1 subject to coherence. A proarrow equipment (framed bicategory) is a double category in which the frame functor (L,R): D_1 -> D_0 × D_0 is a fibration."
    Ref: PROARROW-EQUIPMENT

  - ID: ADB-PROF-AS-EQUIPMENT-01
    Def: "Prof is a proarrow equipment with objects small categories, vertical morphisms functors, horizontal 1-cells profunctors, and 2-cells transformations."
    Ref: ADB-PROARROW-EQUIPMENT-DEF-01

  - ID: ADB-COLLAGES-DEF-01
    Def: "An equipment D has collages if every proarrow M: A ⇸ B has a universal cocone from M to a single object. If every such collage is a cartesian lifting, the collages are normal."

  - ID: ADB-COLLAGE-PROP-01
    Def: "In Prof, the collage of a profunctor M: C ⇸ D has objects Ob(C) ⊔ Ob(D), and hom-sets defined piecewise by C(c,c'), D(d,d'), and M(c,d)."
    Ref: ADB-COLLAGES-DEF-01

  - ID: ADB-EXTENSIVE-COLLAGES-DEF-01
    Def: "An equipment D has extensive collages if it has local colimits, normal collages, and a certain functor MResN is an equivalence of categories."

  - ID: ADB-EXTENSIVE-COLLAGES-PROP-01
    Def: "Prof has extensive collages."
    Ref: ADB-EXTENSIVE-COLLAGES-DEF-01

Algebraic_Theories:
  - ID: ADB-ALG-THEORY-DEF-01
    Def: "A (multi-sorted) algebraic theory is a cartesian strict monoidal category T with a set S_T of base sorts, such that the monoid of objects of T is free on S_T. A morphism of theories T -> T' is a product-preserving functor sending base sorts to base sorts."

  - ID: ADB-ALG-ALGEBRA-DEF-01
    Def: "An algebra over T is a product-preserving functor T -> Set. The category of such algebras is denoted T-Alg."
    Ref: ADB-ALG-THEORY-DEF-01

  - ID: ADB-ALG-PROFUNCTOR-DEF-01
    Def: "A profunctor M: C ⇸ T, where T is an algebraic theory, is algebraic if M(c,-): T -> Set preserves finite products for each c in C. Equivalently, M: T -> Set^{C^op} factors through T-Alg."

  - ID: ADB-ALG-LEFT-TENSOR-01
    Def: "For M: C ⇸ D and an algebraic profunctor N: D ⇸ T, their left tensor M ⊗ N: C ⇸ T is given by the composition Λ_N ∘ M: C^op -> T-Alg."

Presentations_and_Syntax:
  - ID: ADB-SIGNATURE-DEF-01
    Def: "An algebraic signature Σ has a set S_Σ of base sorts and a set Φ_Σ of function symbols f: (s1,...,sn) -> s'. A morphism of signatures maps sorts to sorts and function symbols accordingly."

  - ID: ADB-PRESENTATION-THEORY-DEF-01
    Def: "A presentation (Σ,E) of an algebraic theory T is a signature Σ and a set E of equations over Σ such that T ≅ Cxt_Σ / E (the free theory on Σ quotiented by E)."

  - ID: ADB-PRESENTATION-CATEGORY-DEF-01
    Def: "A category presentation is a pair (G,E) where G is a graph (unary signature) and E is a set of unary equations. The category is Fr(G)/E."

Algebraic_Database_Schemas:
  - ID: ADB-SCHEMA-DEF-01
    Def: "A database schema S over an algebraic theory Type is a pair (S_e, S_o) where S_e is a category (the entity category) and S_o: S_e ⇸ Type is an algebraic profunctor (the observables profunctor)."

  - ID: ADB-SCHEMA-MAPPING-DEF-01
    Def: "A schema mapping F: S -> T is a functor F_e: S_e -> T_e together with a 2-cell F_o: S_o ⇒ T_o ∘ F_e^{op} in Prof. The category of schemas is written Schema."

Algebraic_Database_Instances:
  - ID: ADB-INSTANCE-DEF-01
    Def: "If S=(S_e,S_o) is a schema, an instance on S is a functor I: S -> Set whose restriction to Type is a Type-algebra. Equivalently, I is a copresheaf S_e -> Set plus a product-preserving functor I_t: Type -> Set, subject to compatibility."

  - ID: ADB-INST-CATEGORY-DEF-01
    Def: "Denote by S-Inst the category of instances and natural transformations."

  - ID: ADB-INST-PROP-01
    Def: "S-Inst is equivalent to a category of algebras for some algebraic theory."

  - ID: ADB-INST-COR-01
    Def: "S-Inst has all small colimits."

Fundamental_Data_Migration_Functors:
  - ID: ADB-MIGRATION-OVERVIEW-01
    Def: "Given a schema mapping F: S -> T, there are three functors S-Inst ⇆ T-Inst: pullback Δ_F, left pushforward Σ_F, right pushforward Π_F."
    Ref: [MIGRATION-DELTA, MIGRATION-SIGMA, MIGRATION-PI]

  - ID: ADB-DELTA-DEF-01
    Def: "For I in T-Inst, Δ_F(I) = I ∘ F."
    Ref: MIGRATION-DELTA

  - ID: ADB-PI-PROP-01
    Def: "Δ_F has a right adjoint Π_F, obtained as a right Kan extension."
    Ref: MIGRATION-PI

  - ID: ADB-SIGMA-PROP-01
    Def: "Δ_F has a left adjoint Σ_F. For I in S-Inst, Σ_F(I) = ∫^{s in S_e} I(s) · y(Fs)."
    Ref: MIGRATION-SIGMA

Double_Category_Data:
  - ID: ADB-DATA-DEF-01
    Def: "Data is the double category whose objects are schemas, vertical morphisms are schema mappings, horizontal morphisms are bimodules, and 2-cells are transformations respecting the type side."

  - ID: ADB-DATA-COMPOSITION-01
    Def: "The composition M ⊗ N of bimodules M: R ⇸ S and N: S ⇸ T is given by M ⊗ N = Λ_N ∘ M."

  - ID: ADB-DATA-EQUIPMENT-01
    Def: "Data is an equipment."

Queries_and_Uber_Queries:
  - ID: ADB-QUERY-DEF-01
    Def: "A query Q on a schema S can be presented as a FOR-WHERE-RETURN specification, yielding a schema R (with one entity) and a bimodule M: R ⇸ S. Evaluating the query on an instance J is the functor Γ_M(J)."
    Ref: GAMMA-EVALUATION

  - ID: ADB-UBER-QUERY-DEF-01
    Def: "A bimodule N: L ⇸ S can be seen as a more general query or uber-query, possibly returning multiple tables or referencing other queries."
    Ref: UBER-QUERY

Implementation:
  - ID: ADB-IMPL-WORD-PROBLEM-01
    Def: "Each finite presentation of categories or instances requires a decision procedure for the word problem, typically resolved by rewriting systems such as Knuth-Bendix completion."

Appendix_A:
  - ID: ADB-APP-A-01
    Componentwise_Composition: "For two bimodules M: R ⇸ S and N: S ⇸ T, the composite M ⊗ N can be expressed in components via a pushout in [R_e^{op}, Type-Alg]."
    Horizontal_2_cells: "The horizontal composition of 2-cells can be computed similarly by a pushout in the appropriate functor category."
    Exponentiation: "If N: S ⇸ T and P: R ⇸ T are bimodules, then N ◁ P can be described by pointwise pullbacks."
