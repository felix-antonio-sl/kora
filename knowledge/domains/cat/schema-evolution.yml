# KODA Knowledge Artifact: Schema Evolution and Behavioral Audit
# Domain: Category Theory / Temporal Evolution / Behavioral Dynamics
# Purpose: Audit migrations, versions, and behavior over time

_manifest:
  urn: "urn:knowledge:koda:cat:schema-evolution:1.0.0"
  federation:
    visibility: internal
    license: "CC-BY-4.0"
  compatibility:
    min_consumer_version: "1.0.0"
    breaking_changes_from: null
  resolution:
    canonical_url: "file://knowledge/domains/cat/meta/schema_evolution.koda.yml"
    mirrors: []
  dependencies:
    requires:
      - urn: "urn:knowledge:koda:core:spec:1.0.0"
      - urn: "urn:knowledge:koda:cat:seven-sketches:1.0.0"
      - urn: "urn:knowledge:koda:cat:coalgebras:1.0.0"
      - urn: "urn:knowledge:koda:cat:cql-data-integration:1.0.0"
      - urn: "urn:knowledge:koda:cat:constraint-logic:1.0.0"
  provenance:
    created_by: "FS"
    created_at: "2025-12-05"
    last_modified_by: "FS"
    last_modified_at: "2025-12-05"
    signature: null

ID: CAT-EVOLUTION-01
Version: 1.0.0
Status: Active
Human-Creator: FS
Human-Editor: FS
Model-Collaborator: Cascade
Creation-Date: 2025-12-05
Modification-Date: 2025-12-14
Version-Notes: "Initial KODA/Spec for Schema Evolution and Behavioral Audit."
Ctx: "Auditoría de migraciones, versiones y comportamiento a lo largo del tiempo."

LLM_Parsing_Instructions:
  ID: KODA-LLM-PARSER-01
  Req: Mandatory block following Metadata.
  Content: |
    BEGIN_LLM_INSTRUCTIONS
    You are an AI agent consuming a KODA artifact. Parse with absolute fidelity.
    LEXICON (expand before processing): Act->Action, Cond->Condition, Ctx->Context, Ctx_Required->Required External Reference, Ctx_Optional->Optional External Reference, Def->Definition, Ex->Example, Mssn->Mission, Obj->Objective, Proc->Process, Purp->Purpose, Ref->Reference, XRef->Cross-Artifact Reference, XRef_Required->Mandatory Cross-Artifact Reference, Req->Requirement, Res->Result, Src->Source, Prohib->Prohibition, Warn->Warning, Just->Justification, Rec->Recommendation

    REFERENCE POLICY: Ref: internal only. XRef: external URN only.
    END_LLM_INSTRUCTIONS

Purp: "Formalizar evolución temporal de esquemas y auditoría de comportamiento dinámico."
Obj: "Extender auditoría de fotos estáticas a procesos temporales y dinámicos."

Related_Concepts:
  XRef:
    - "urn:knowledge:koda:cat:seven-sketches:1.0.0#MIGRATION-DELTA"
    - "urn:knowledge:koda:cat:coalgebras:1.0.0#BISIMULATION"
    - "urn:knowledge:koda:cat:cql-data-integration:1.0.0#CQL-PROVENANCE"
    - "urn:knowledge:koda:cat:constraint-logic:1.0.0#CL-MIGRATION-AUDIT"

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 1: CATEGORÍA DE VERSIONES
# ═══════════════════════════════════════════════════════════════════════════

Version_Category:
  - ID: EVOLUTION-VER-CAT
    Def: "Ver es una categoría donde objetos = versiones y morfismos = migraciones."
    Structure:
      Objects: |
        Versiones de un esquema/modelo/artefacto:
        v1.0.0, v1.1.0, v2.0.0, ...
      Morphisms: |
        Migraciones entre versiones:
        upgrade: v_n → v_{n+1}
        downgrade: v_{n+1} → v_n (si existe)
      Identity: "Cada versión tiene migración identidad (no-op)."
      Composition: "upgrade_{n,n+1} ; upgrade_{n+1,n+2} = upgrade_{n,n+2}."
    Properties:
      - "Ver es típicamente un preorden (a lo sumo un morfismo entre versiones)."
      - "Si hay upgrades y downgrades compatibles, puede ser grupoide parcial."

  - ID: EVOLUTION-SCHEMA-FUNCTOR
    Def: "Funtor F: Ver → Cat que asigna a cada versión su esquema."
    Structure: |
      F(v_n) = S_n (esquema en versión n)
      F(upgrade) = funtor de migración F_{n,n+1}: S_n → S_{n+1}
    Use: "Formalizar cómo evoluciona el esquema a través de versiones."
    Ex: |
      F(v1.0.0) = S₁ con {Employee, Department}
      F(v1.1.0) = S₂ con {Employee, Department, Project}
      F(upgrade_{1.0,1.1}) = inclusión S₁ ↪ S₂

  - ID: EVOLUTION-INSTANCE-FIBRATION
    Def: "Fibración que conecta instancias con sus versiones de esquema."
    Structure: |
      Para cada versión v, categoría de instancias Inst(F(v)).
      Migración upgrade_{n,n+1} induce funtor Δ/Σ/Π entre categorías de instancias.
    Diagram: |
                Inst(S₁) ----Σ_F----> Inst(S₂)
                   |                     |
                   v                     v
                  v1.0.0 ---upgrade---> v1.1.0

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 2: AUDITORÍA DE CADENAS DE MIGRACIÓN
# ═══════════════════════════════════════════════════════════════════════════

Migration_Chain_Audit:
  - ID: EVOLUTION-MIGRATION-CHAIN
    Def: "Una cadena de migraciones es una secuencia v₁ → v₂ → ... → vₙ."
    Audit_Goals:
      - "Verificar que cada migración individual es funtorial."
      - "Verificar que la composición preserva invariantes críticos."
      - "Detectar pérdida acumulativa de información/constraints."

  - ID: EVOLUTION-CHAIN-AUDIT-PROC
    Def: "Procedimiento de auditoría de cadena de migraciones."
    Proc: |
      1. INVENTARIO DE VERSIONES
         a) Listar versiones: v₁, v₂, ..., vₙ.
         b) Listar migraciones: m₁: v₁→v₂, m₂: v₂→v₃, ..., m_{n-1}: v_{n-1}→vₙ.
      
      2. AUDITORÍA INDIVIDUAL DE MIGRACIONES
         Para cada mᵢ:
         a) Verificar que mᵢ es funtor válido (preserva id, composición).
         b) Identificar operador usado (Δ, Σ, Π, o combinación).
         c) Aplicar CL-MIGRATION-AUDIT para constraints.
         d) Registrar: constraints preservadas, constraints perdidas.
      
      3. AUDITORÍA DE COMPOSICIÓN
         a) Calcular composición m = m_{n-1} ∘ ... ∘ m₁.
         b) Verificar que m: S₁ → Sₙ es funtor válido.
         c) Comparar constraints de T₁ con constraints de Tₙ.
         d) Identificar constraints que se perdieron en la cadena.
      
      4. ANÁLISIS DE PROVENANCE
         a) Para datos en Sₙ, rastrear origen en S₁.
         b) Verificar que provenance es trazable a través de toda la cadena.
         c) Detectar datos "huérfanos" (sin origen claro).
      
      5. ANÁLISIS DE INVARIANTES
         a) Identificar invariantes críticos (constraints que DEBEN preservarse).
         b) Verificar preservación a lo largo de toda la cadena.
         c) Si invariante crítico se pierde → CRITICAL.
      
      6. GENERAR INFORME
         a) Mapa de versiones y migraciones.
         b) Constraints preservadas vs perdidas por migración.
         c) Invariantes críticos: estado final.
         d) Recomendaciones de mejora.
    XRef: "urn:knowledge:koda:cat:constraint-logic:1.0.0#CL-MIGRATION-AUDIT"

  - ID: EVOLUTION-DEBT-DETECTION
    Def: "Detectar deuda técnica categórica en evolución de esquemas."
    Symptoms:
      - "Esquema actual no satisface constraints de versión anterior."
      - "Migraciones ad-hoc que no son funtoriales."
      - "Constraints importantes que se fueron perdiendo gradualmente."
      - "Datos migrados que ya no cumplen invariantes originales."
    Proc: |
      1. Cargar constraints de v₁ (versión original).
      2. Cargar instancia actual I en vₙ.
      3. Intentar verificar constraints originales en datos actuales.
      4. Diferencia = deuda categórica acumulada.
      5. Proponer plan de "pago de deuda": refactoring para restaurar invariantes.

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 3: AUDITORÍA COMPORTAMENTAL (DINÁMICA)
# ═══════════════════════════════════════════════════════════════════════════

Behavioral_Audit:
  - ID: EVOLUTION-BEHAVIOR-DEF
    Def: "El comportamiento de un sistema se captura como coálgebra c: U → F(U)."
    Components:
      State_Space: "U = espacio de estados (oculto)."
      Interface_Functor: "F = forma de la interfaz (outputs, transiciones)."
      Coalgebra: "c asigna a cada estado su comportamiento observable."
    XRef: "urn:knowledge:koda:cat:coalgebras:1.0.0#COALGEBRA-DEF"

  - ID: EVOLUTION-BISIM-AUDIT
    Def: "Auditar equivalencia comportamental entre versiones de un sistema."
    Proc: |
      1. MODELAR VERSIONES COMO COÁLGEBRAS
         a) Sistema v₁: (U₁, c₁: U₁ → F(U₁))
         b) Sistema v₂: (U₂, c₂: U₂ → F(U₂))
         c) Verificar que ambos usan el mismo funtor de interfaz F.
      
      2. VERIFICAR BISIMULACIÓN
         a) Buscar relación R ⊆ U₁ × U₂ tal que:
            - Si (u₁, u₂) ∈ R, entonces output(c₁(u₁)) = output(c₂(u₂)).
            - Si (u₁, u₂) ∈ R y u₁ transiciona a u₁', existe u₂' tal que
              u₂ transiciona a u₂' y (u₁', u₂') ∈ R.
         b) Alternativa: verificar via coálgebra final.
            - beh₁(u₁) = beh₂(u₂) para estados correspondientes.
      
      3. ANALIZAR DIFERENCIAS
         Si no son bisimilares:
         a) Identificar estados donde divergen.
         b) Identificar secuencias de inputs que producen outputs diferentes.
         c) Clasificar: ¿es cambio intencional o regresión?
      
      4. GENERAR INFORME
         a) ¿Son bisimilares? Sí/No.
         b) Si no: puntos de divergencia.
         c) Recomendación: documentar cambio o corregir regresión.
    XRef: "urn:knowledge:koda:cat:coalgebras:1.0.0#BISIMULATION"

  - ID: EVOLUTION-ACTION-AUDIT
    Def: "Auditar logs/episodios usando acción como clave primaria."
    Proc: |
      1. VERIFICAR ESTRUCTURA EPISÓDICA
         a) Cada episodio tiene acción indexadora.
         b) Acción es morfismo en la categoría de dominio.
         c) No hay episodios "huérfanos" sin acción.
      
      2. VERIFICAR COMPOSICIONALIDAD
         a) Si episodio E₁ seguido de E₂, ¿la composición de acciones está registrada?
         b) Secuencias de acciones forman paths en la categoría.
      
      3. VERIFICAR CONSISTENCIA TEMPORAL
         a) Las acciones respetan orden temporal.
         b) No hay "viajes en el tiempo" (efectos antes de causas).
      
      4. VERIFICAR CONSTRAINTS SOBRE ACCIONES
         a) ¿Las acciones satisfacen precondiciones declaradas?
         b) ¿Los resultados satisfacen postcondiciones?
      
      5. GENERAR INFORME
         a) Cobertura de episodios por acciones.
         b) Anomalías temporales.
         c) Violaciones de pre/postcondiciones.

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 4: PROVENANCE CATEGÓRICO
# ═══════════════════════════════════════════════════════════════════════════

Categorical_Provenance:
  - ID: EVOLUTION-PROVENANCE-DEF
    Def: "Provenance = rastreo del origen de cada dato a través de transformaciones."
    Formal: |
      Dado dato d en instancia J: T → Set,
      provenance(d) = conjunto de datos en I: S → Set que contribuyeron a d
      a través de la migración F: S → T.
    XRef: "urn:knowledge:koda:cat:cql-data-integration:1.0.0#CQL-PROVENANCE"

  - ID: EVOLUTION-PROVENANCE-AUDIT
    Def: "Auditar que el provenance es completo y correcto."
    Proc: |
      1. COMPLETITUD
         a) Para cada dato d en target, ¿tiene provenance definido?
         b) Si d no tiene origen → WARN: dato sin provenance.
      
      2. CORRECCIÓN
         a) Si provenance(d) = {s₁, ..., sₖ}, ¿aplicar la migración a sᵢ produce d?
         b) Verificar que la transformación declarada coincide con resultado.
      
      3. MINIMALIDAD
         a) ¿El provenance incluye solo datos necesarios?
         b) Datos en provenance que no contribuyen → ineficiencia (no error).
      
      4. TRANSITIVIDAD
         a) Si hay cadena de migraciones, ¿provenance es transitivo?
         b) provenance(d en v₃) debe rastrear hasta v₁.
      
      5. GENERAR INFORME
         a) Cobertura de provenance.
         b) Datos sin origen.
         c) Inconsistencias de provenance.

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 5: PROCEDIMIENTO COMPLETO DE AUDITORÍA TEMPORAL
# ═══════════════════════════════════════════════════════════════════════════

Temporal_Audit_Procedure:
  - ID: EVOLUTION-FULL-AUDIT
    Def: "Procedimiento completo de auditoría temporal y comportamental."
    Proc: |
      1. DETERMINAR ALCANCE
         a) ¿Es auditoría de evolución de esquemas? → Sección 2.
         b) ¿Es auditoría de comportamiento? → Sección 3.
         c) ¿Es auditoría de provenance? → Sección 4.
         d) ¿Es combinación? → Ejecutar todas las aplicables.
      
      2. SI EVOLUCIÓN DE ESQUEMAS:
         a) Construir categoría Ver.
         b) Identificar funtor F: Ver → Cat.
         c) Ejecutar EVOLUTION-CHAIN-AUDIT-PROC.
         d) Ejecutar EVOLUTION-DEBT-DETECTION.
      
      3. SI COMPORTAMIENTO:
         a) Modelar sistema(s) como coálgebra(s).
         b) Si comparando versiones: EVOLUTION-BISIM-AUDIT.
         c) Si auditando logs: EVOLUTION-ACTION-AUDIT.
      
      4. SI PROVENANCE:
         a) Identificar migraciones involucradas.
         b) Ejecutar EVOLUTION-PROVENANCE-AUDIT.
      
      5. CONSOLIDAR INFORME
         a) Resumen por dimensión auditada.
         b) Issues encontrados.
         c) Propuestas de mejora.
    
    Output_Format: |
      ## Informe de Auditoría Temporal/Comportamental
      
      ### 1. Alcance
      - Evolución de esquemas: ✓/✗
      - Comportamiento: ✓/✗
      - Provenance: ✓/✗
      
      ### 2. Evolución (si aplica)
      | Versión | Constraints | Preservadas | Perdidas |
      |---------|-------------|-------------|----------|
      
      ### 3. Comportamiento (si aplica)
      | Sistema A | Sistema B | Bisimilares | Divergencias |
      |-----------|-----------|-------------|--------------|
      
      ### 4. Provenance (si aplica)
      | Cobertura | Sin origen | Inconsistencias |
      |-----------|------------|-----------------|
      
      ### 5. Issues y Propuestas
      [Lista consolidada]


