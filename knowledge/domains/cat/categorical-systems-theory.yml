# KODA Knowledge Artifact: Categorical Systems Theory
# Domain: Category Theory / Dynamical Systems

_manifest:
  urn: "urn:knowledge:koda:cat:categorical-systems-theory:1.0.0"
  federation:
    visibility: internal
    license: "CC-BY-4.0"
  compatibility:
    min_consumer_version: "1.0.0"
    breaking_changes_from: null
  resolution:
    canonical_url: "file://knowledge/domains/cat/dynamics/categorical_systems_theory.koda.yml"
    mirrors: []
  dependencies:
    requires:
      - urn: "urn:knowledge:koda:core:spec:1.0.0"
  provenance:
    created_by: "FS"
    created_at: "2025-12-05"
    last_modified_by: "FS"
    last_modified_at: "2025-12-14"
    signature: null

ID: CAT-SYS-01
Version: 1.0.0
Status: Active
Human-Creator: FS
Human-Editor: FS
Model-Collaborator: Cascade
Creation-Date: 2025-12-05
Modification-Date: 2025-12-14
Version-Notes: "Initial KODA/Spec content for Categorical Systems Theory. Updated with Preface + Chapter 1–2 definitions/propositions from sources/cat."
Src:
  - "file://sources/cat/Categorical Systems Theory.md"
Ctx: "Notas estructuradas sobre lenses, wiring diagrams, monads y análisis de comportamiento."

LLM_Parsing_Instructions:
  ID: KODA-LLM-PARSER-01
  Req: Mandatory block following Metadata.
  Prohib: Using for artifact creation or translation.
  Content: |
    BEGIN_LLM_INSTRUCTIONS
    You are an AI agent consuming a KODA artifact. Parse with absolute fidelity.

    FIDELITY: Preserve meat (essential information) and skeleton (structure: headers, IDs, lists, tables) with zero loss. Ignore fat (filler words, rhetoric, stylistic prose).

    LEXICON (expand before processing): Act->Action, Cond->Condition, Ctx->Context, Ctx_Required->Required External Reference, Ctx_Optional->Optional External Reference, Def->Definition, Ex->Example, Mssn->Mission, Obj->Objective, Proc->Process, Purp->Purpose, Ref->Reference, XRef->Cross-Artifact Reference, XRef_Required->Mandatory Cross-Artifact Reference, Req->Requirement, Res->Result, Src->Source, Prohib->Prohibition, Warn->Warning, Just->Justification, Rec->Recommendation

    REFERENCE POLICY: Ref: is internal only—must point to existing ID within THIS document. XRef/XRef_Required: are external only—must point to a URN (optionally with #ID fragment) in another artifact. External documents without specific ID use Ctx:, Ctx_Required:, or Ctx_Optional:.

    LANGUAGE POLICY: Keywords in English, content in original language. Never translate content.
    END_LLM_INSTRUCTIONS

Purp: "Registrar el marco de sistemas categóricos para modelar arquitecturas dinámicas."
Obj: "Servir de fuente formal para CM-BEHAVIOR-ENGINE (lenses, sistemas monádicos, wiring diagrams)."

Source:
  Title: "Categorical Systems Theory"
  Authors: []
  Ctx: "This book is a work in progress. It aims to develop categorical systems theory, applying category-theoretic ideas to general systems theory."

Preface:
  ID: CST-PREFACE-01
  Def: "This book is a work in progress. It aims to develop categorical systems theory, an emerging field applying category-theoretic ideas to general systems theory."
  Approach:
    - "A system interacts with its environment through a specified interface."
    - "From the environment’s view, only the system’s interface matters."
    - "Systems interact with each other via these interfaces, which can be composed using composition patterns."
    - "Composition yields complex systems, promoting modularity."
  Focus:
    - "Modularity: how to build larger systems from smaller ones."
    - "Compositionality: facts about composite systems can be calculated from their components and wiring."
  Provides:
    - "A doctrine of dynamical systems: answers to what is a system, interface, composition pattern, etc.?"
    - "A systems theory: describing how states, inputs, outputs, and dynamics are defined."
    - "A compositionality theorem: behaviors of composite systems can be calculated from components and wiring patterns."
  Tools: "Uses standard category theory, indexed categories, and double categories; leads to a theorem about representable lax doubly indexed functors."

Chapter_1_Wiring_Together_Dynamical_Systems:
  ID: CST-CH1-01

  Section_1_1_Introduction:
    ID: CST-CH1-SEC-1-1

    Informal_Definition_1_1_0_1_Dynamical_System:
      ID: CST-CH1-DEF-1-1-0-1
      Def: "A dynamical system consists of states (a notion of how things can be) and dynamics (a notion of how things will change given how they are, potentially depending on parameters/inputs)."

    Informal_Definition_1_1_0_2_Systems_Theory:
      ID: CST-CH1-DEF-1-1-0-2
      Def: "A theory of dynamical systems (systems theory) is a particular way to answer what it means to be a state; how outputs vary with the state; what inputs exist and how they depend on state; what changes are possible in a given state; how states change (deterministically, stochastically, etc.); and how these changes depend on inputs."

    Informal_Definition_1_1_0_3_Composition:
      ID: CST-CH1-DEF-1-1-0-3
      Def: "Composition is the process of bringing several things (systems) together to form a bigger thing, typically by plugging outputs into inputs."

    Informal_Definition_1_1_0_4_Category_Theory:
      ID: CST-CH1-DEF-1-1-0-4
      Def: "Category theory is the abstract study of composition."

  Section_1_1_1_Category_Theory:
    ID: CST-CH1-SEC-1-1-1

    Definition_1_1_1_1_Cartesian_Category:
      ID: CST-CH1-DEF-1-1-1-1
      Def: "A category C is cartesian if it has all finite products and a terminal object. A functor F: C -> D between cartesian categories is cartesian if it preserves products and terminal objects."

  Section_1_2_Deterministic_and_Differential_Systems_Theories:
    ID: CST-CH1-SEC-1-2

    Deterministic_System:
      ID: CST-CH1-DEF-1-2-1-2
      Def: "A deterministic system S consists of State_S, Out_S, In_S, an expose_S: State_S -> Out_S, and an update_S: State_S × In_S -> State_S giving the next state."
      Components:
        State_S: "a set of states"
        Out_S: "a set of output values (exposed variables)"
        In_S: "a set of input values (parameters)"
        expose_S: "State_S -> Out_S"
        update_S: "State_S × In_S -> State_S"
      Remark: "In any cartesian category C, one may interpret State_S, Out_S, In_S as objects of C, and expose_S, update_S as morphisms."
      Ref: CST-CH1-DEF-1-1-1-1

    Example_1_2_1_4_Clock:
      ID: CST-CH1-EX-1-2-1-4
      State_Clock: "{1,2,...,12}"
      Out_Clock: "{1,2,...,12}"
      In_Clock: "{*}"
      expose_Clock: "id"
      update_Clock: "update_Clock(t,*) = tick(t)"
      Ref: CST-CH1-DEF-1-2-1-2

    Example_1_2_1_7_SIR_Discrete:
      ID: CST-CH1-EX-1-2-1-7
      Def: "States are triples (s,i,r) with s,i,r in R. Parameters (alpha,beta) encode infection and removal rates."
      Update: "update_SIR((s,i,r),(alpha,beta)) = (s - alpha*s*i, i + alpha*s*i - beta*i, r + beta*i)."
      Ref: CST-CH1-DEF-1-2-1-2

    Definition_1_2_1_11_Closed_System:
      ID: CST-CH1-DEF-1-2-1-11
      Def: "A closed system is one having no inputs and no outputs, i.e. both In_S and Out_S are singletons."

    Differential_System:
      ID: CST-CH1-DEF-1-2-2-1
      Def: "A (first-order, ordinary) differential system S with n state variables, m parameters, and k exposed variables has State_S = R^n, In_S = R^m, Out_S = R^k, an update_S: R^n × R^m -> R^n encoding differential equations d s / dt = update_S(s,i), and expose_S: R^n -> R^k."

    Remark_1_2_2_2:
      ID: CST-CH1-REM-1-2-2-2
      Def: "Though this resembles a deterministic system in the category of smooth maps Euc, the R^n on the right is a tangent space rather than a next state; this matters for behaviors/trajectories."

    Definition_1_2_2_7_Euc:
      ID: CST-CH1-DEF-1-2-2-7
      Def: "Euc is the category whose objects are R^n (n in N) and whose morphisms are smooth maps; it is cartesian with R^n × R^m = R^{n+m} and terminal object R^0."
      Ref: CST-CH1-DEF-1-1-1-1

  Section_1_3_Wiring_Together_Systems_with_Lenses:
    ID: CST-CH1-SEC-1-3

    Definition_1_3_1_1_Lens:
      ID: CST-CH1-DEF-1-3-1-1
      Def: "A lens in a cartesian category C consists of a pass-forward map f: A^+ -> B^+ and a pass-back map f^sharp: A^+ × B^- -> A^-."
      Ref: CST-CH1-DEF-1-1-1-1

    Definition_1_3_1_2_Lens_Composition:
      ID: CST-CH1-DEF-1-3-1-2
      Def: "The composition of lenses (f^sharp,f): (A^-,A^+) -> (B^-,B^+) and (g^sharp,g): (B^-,B^+) -> (C^-,C^+) has pass-forward g ∘ f and pass-back defined by (a^+,c^-) |-> f^sharp(a^+, g^sharp(f(a^+), c^-))."
      Ref: CST-CH1-DEF-1-3-1-1

    Definition_1_3_1_4_Lens_Category:
      ID: CST-CH1-DEF-1-3-1-4
      Def: "Lens_C is the category whose objects are pairs (A^-,A^+) of objects in C, and whose morphisms are lenses between them."

    Proposition_1_3_1_7_Functoriality_of_Lens:
      ID: CST-CH1-PROP-1-3-1-7
      Def: "Every cartesian functor F: C -> D induces a functor Lens_C -> Lens_D."
      Ref: CST-CH1-DEF-1-1-1-1

    Deterministic_and_Differential_as_Lenses:
      ID: CST-CH1-REM-1-3-2
      Def: "A deterministic system is a lens of the form (update_S, expose_S): State_S <-> (In_S, Out_S). A differential system can be regarded as a lens in Euc with the same shape."
      Ref: [CST-CH1-DEF-1-2-1-2, CST-CH1-DEF-1-2-2-1, CST-CH1-DEF-1-2-2-7]

    Parallel_Product_of_Lenses:
      ID: CST-CH1-DEF-1-3-2-PP
      Def: "Parallel products of lenses place systems side by side; this yields a monoidal structure on Lens_C."

    Proposition_1_3_2_4_Parallel_Product_Preserved:
      ID: CST-CH1-PROP-1-3-2-4
      Def: "If F: C -> D is a cartesian functor, the induced functor Lens_C -> Lens_D preserves the parallel product."
      Ref: CST-CH1-DEF-1-3-1-4

    Definition_1_3_3_2_Arity:
      ID: CST-CH1-DEF-1-3-3-2
      Def: "Arity is the free cartesian category on one object X. Concretely, objects are X^I for finite sets I, and morphisms are reindexing maps derived from functions f*: X^I -> X^J for f: J -> I."

    Proposition_1_3_3_3_Arity_Is_FinSet_op:
      ID: CST-CH1-PROP-1-3-3-3
      Def: "Arity is isomorphic to FinSet^op, the opposite of finite sets."

    Definition_1_3_3_5_Category_of_Wiring_Diagrams:
      ID: CST-CH1-DEF-1-3-3-5
      Def: "WD := Lens_Arity is the category of wiring diagrams; parallel products endow it with a monoidal structure."
      Ref: [CST-CH1-DEF-1-3-1-4, CST-CH1-DEF-1-3-3-2]

    Proposition_1_3_3_7_Universal_Property_of_Arity:
      ID: CST-CH1-PROP-1-3-3-7
      Def: "For a cartesian category C and an object C in C, there is a unique (up to isomorphism) cartesian functor ev_C: Arity -> C sending X to C; hence any wiring diagram can be interpreted as a lens in C."
      Ref: CST-CH1-DEF-1-3-3-2

    Proposition_1_3_3_15_Typed_Wiring_Diagrams:
      ID: CST-CH1-PROP-1-3-3-15
      Def: "Given a family C(-): T -> C in a cartesian category C, there is a strong monoidal functor ev_C: WD_T -> Lens_C interpreting typed wiring diagrams as lenses in C."

    Definition_1_3_4_1_Algebraic_Theory:
      ID: CST-CH1-DEF-1-3-4-1
      Def: "An algebraic theory T consists of a set T_n of n-ary operations for each n, subject to equational laws."

    Definition_1_3_4_5_Lawvere_Theory:
      ID: CST-CH1-DEF-1-3-4-5
      Def: "A (single-sorted) Lawvere theory L is a cartesian category equipped with a bijective-on-objects functor Arity -> L. Models of L in a cartesian category C are cartesian functors L -> C."
      Ref: CST-CH1-DEF-1-3-3-2

    Proposition_1_3_4_9_Vect_Model:
      ID: CST-CH1-PROP-1-3-4-9
      Def: "Any vector space structure on an object V in a cartesian category C induces a unique (up to isomorphism) cartesian functor V-hat: Vect -> C sending R to V, where Vect is the Lawvere theory of real vector spaces."

    Definition_1_3_4_10_WD_with_Operations:
      ID: CST-CH1-DEF-1-3-4-10
      Def: "For a Lawvere theory L, the category of wiring diagrams with operations from L is WD_L := Lens_L."
      Ref: CST-CH1-DEF-1-3-4-5

Chapter_2_Non_deterministic_systems_theories:
  ID: CST-CH2-01

  Section_2_1_Possibilistic_systems:
    ID: CST-CH2-SEC-2-1

    Definition_2_1_0_1_Possibilistic_System:
      ID: CST-CH2-DEF-2-1-0-1
      Def: "A possibilistic system S consists of State_S, Out_S, In_S, expose_S: State_S -> Out_S, and update_S: State_S × In_S -> P(State_S), where P(State_S) is the powerset of State_S."

    Definition_2_1_0_5_Commutative_Monad:
      ID: CST-CH2-DEF-2-1-0-5
      Def: "A monad (M, eta) on a cartesian category C consists of an assignment MA to every A, a map eta_A: A -> MA, and for every f: A -> MB a lift f^M: MA -> MB satisfying unit/identity/composition laws; equivalently, a functor M with natural transformations eta and mu: M^2 A -> MA. A monad M is commutative if there is a natural transformation sigma: MA × MB -> M(A × B) making the commutativity diagrams commute."

    Proposition_2_1_0_7_Powerset_Commutative_Monad:
      ID: CST-CH2-PROP-2-1-0-7
      Def: "The powerset P is a commutative monad on Set with eta_A(a) = {a}, f^P(X) = union_{x in X} f(x), and sigma_{A,B}(X,Y) = {(a,b) | a in X, b in Y}."
      Ref: CST-CH2-DEF-2-1-0-5

  Section_2_2_Stochastic_systems:
    ID: CST-CH2-SEC-2-2

    Definition_2_2_0_1_Distribution:
      ID: CST-CH2-DEF-2-2-0-1
      Def: "For a set A, D A is the set of finitely supported probability distributions on A (p: A -> [0,1] with finite support and sum 1); equivalently, formal convex combinations of elements of A."

    Definition_2_2_0_3_Stochastic_Map:
      ID: CST-CH2-DEF-2-2-0-3
      Def: "A stochastic map f: A -> D B sends each a in A to a probability distribution on B (classically, f(a)(b) = p(b | a))."
      Ref: CST-CH2-DEF-2-2-0-1

    Definition_2_2_0_5_Stochastic_System:
      ID: CST-CH2-DEF-2-2-0-5
      Def: "A stochastic system S has State_S, Out_S, In_S, expose_S: State_S -> Out_S, and update_S: State_S × In_S -> D(State_S)."
      Ref: CST-CH2-DEF-2-2-0-1

    Proposition_2_2_0_12_Distribution_Commutative_Monad:
      ID: CST-CH2-PROP-2-2-0-12
      Def: "D is a commutative monad on Set: eta_A(a) is the Dirac delta distribution; f^D pushes forward a distribution by summation; sigma_{A,B} forms the product measure of independent distributions."
      Ref: CST-CH2-DEF-2-1-0-5

  Section_2_3_Kleisli_category_and_M_systems:
    ID: CST-CH2-SEC-2-3

    Definition_2_3_0_1_Kleisli_Category:
      ID: CST-CH2-DEF-2-3-0-1
      Def: "Let M be a commutative monad on a cartesian category C. The Kleisli category Kl(M) has the same objects as C; morphisms f: A ~> B given by maps A -> M B in C; identity id_A = eta_A; and composition f;g = f (g)^M."
      Ref: CST-CH2-DEF-2-1-0-5

    Definition_2_3_0_4_M_System:
      ID: CST-CH2-DEF-2-3-0-4
      Def: "A (discrete-time) M-system S has State_S, Out_S, In_S, expose_S, and a Kleisli map update_S: State_S × In_S -> M(State_S)."
      Ref: CST-CH2-DEF-2-3-0-1

  Section_2_6_Generalized_Lens_Construction:
    ID: CST-CH2-SEC-2-6

    Indexed_Category_Definition:
      ID: CST-CH2-DEF-INDEXED-CATEGORY
      Def: "A strict indexed category A: C^op -> Cat assigns to each C a category A(C), plus functorial reindexing."

    Grothendieck_Construction:
      ID: CST-CH2-DEF-GROTHENDIECK
      Def: "The Grothendieck construction ∫_{C:C} A(C) forms a category whose objects are pairs (C,A) with A in A(C), and morphisms arise from morphisms in C plus reindexing in A."

    Definition_2_6_2_1_Ctx_C:
      ID: CST-CH2-DEF-2-6-2-1
      Def: "For a cartesian category C and object C, the category Ctx_C has objects = objects of C and morphisms f: X => Y given by maps C × X -> Y; composition uses diagonal Δ and projection π_2."
      Ref: CST-CH1-DEF-1-1-1-1

    Proposition_2_6_2_5_Lens_as_Grothendieck:
      ID: CST-CH2-PROP-2-6-2-5
      Def: "Lens_C (the usual lens category) is the Grothendieck construction ∫_C Ctx_C^op."
      Ref: CST-CH2-DEF-2-6-2-1

    Definition_2_6_2_7_A_Lenses:
      ID: CST-CH2-DEF-2-6-2-7
      Def: "For an indexed category A: C^op -> Cat, Lens_A = ∫_C A(C)^op is the category of A-lenses."
      Ref: CST-CH2-DEF-GROTHENDIECK

    Definition_2_6_4_1_Ctx_C_M:
      ID: CST-CH2-DEF-2-6-4-1
      Def: "Ctx_C^M (the biKleisli category of C×- and M) has objects = objects of C and morphisms f: X => Y given by f: C × X -> M Y; identity is π_2;eta; composition uses Δ; (C×f); λ; M g; μ, where λ: C × M X -> M(C×X) satisfies coherence laws."
      Ref: CST-CH2-DEF-2-3-0-1

    Definition_2_6_4_6_Category_of_M_Lenses:
      ID: CST-CH2-DEF-2-6-4-6
      Def: "The category of M-lenses is Lens_C^M = ∫_C (Ctx_C^M)^op. An M-lens has pass-forward f: A^+ -> B^+ and pass-back f^#: A^+ × B^- -> M(A^-)."
      Ref: CST-CH2-DEF-2-6-4-1

Lens_Theory:
  - ID: LENS-DEF
    Def: "Lens (in a cartesian category) = pass-forward f: A^+ -> B^+ and pass-back f^sharp: A^+ × B^- -> A^-. Deterministic systems are lenses of the form (update_S, expose_S)."
    Structure:
      pass_forward: "f: A^+ -> B^+"
      pass_back: "f^sharp: A^+ × B^- -> A^-"
    Use: "Separar estado interno (S) de interfaz pública (I,O) en arquitecturas de software."
    Ref: [CST-CH1-DEF-1-3-1-1, CST-CH1-DEF-1-2-1-2]

  - ID: LENS-TYPES
    Def: "Tipos de lenses según el tipo de efecto en update."
    Types:
      - ID: LENS-DETERMINISTIC
        Def: "update: S×I→S (sin efectos adicionales)."
        Monad: "Identity"
        Use: "Sistemas deterministas puros."
      - ID: LENS-POSSIBILISTIC
        Def: "update: S×I→P(S) (conjunto de posibles siguientes estados)."
        Monad: "Powerset"
        Use: "No-determinismo, múltiples futuros posibles."
      - ID: LENS-STOCHASTIC
        Def: "update: S×I→D(S) (distribución de probabilidad sobre estados)."
        Monad: "Distribution"
        Use: "Sistemas estocásticos, modelos probabilísticos."
      - ID: LENS-COST
        Def: "update: S×I→(S,Cost)."
        Monad: "Writer"
        Use: "Sistemas con logging o costes acumulados."
    Ref: LENS-DEF

  - ID: LENS-COMPOSITION
    Def: "Las lenses se componen vía wiring diagrams, preservando modularidad."
    Use: "Construir sistemas complejos pegando componentes más simples."
    Proc: |
      1. Definir interfaz de cada componente: Lens_A = (S_A, I_A, O_A, expose_A, update_A).
      2. Identificar conexiones: qué outputs de A alimentan inputs de B.
      3. Construir wiring diagram W que describe las conexiones.
      4. Componer: Lens_AB = W(Lens_A, Lens_B).
      5. El estado compuesto es S_AB = S_A × S_B.
      6. El update compuesto aplica updates en orden topológico según W.
    Ex: |
      -- Lens_Sensor: estado=lectura, output=valor_actual
      -- Lens_Controller: input=sensor_val, estado=target, output=command
      -- Wiring: Sensor.output → Controller.input
      -- Composición: Sistema(sensor_state, controller_state)
      --   update: lee sensor, pasa a controller, genera command

Wiring_Diagrams:
  - ID: WIRING-DEF
    Def: "Wiring diagram = lens in Arity; WD := Lens_Arity is the category of wiring diagrams."
    Use: "Describir arquitecturas como grafos de componentes y conexiones."
    Components:
      Inner_boxes: "Sistemas componentes (lenses, coalgebras, servicios)."
      Outer_box: "Interfaz del sistema compuesto."
      Wires: "Conexiones input→output entre boxes."
    Ex: |
      [Sensor]──sensor_val──▶[Controller]──command──▶[Actuator]
         │                        │                      │
         └────────────────────────┴──────────────────────┘
                        Sistema Compuesto

  - ID: WIRING-LAWVERE
    Def: "Extensión a teorías de Lawvere para sistemas tipados con operaciones algebraicas."
    Use: "Agregar tipos y operaciones (por ejemplo, suma, producto) a los puertos de sistemas."
    Ref: WIRING-DEF

  - ID: WIRING-PROC
    Def: "Procedimiento para construir un wiring diagram."
    Proc: |
      1. Listar todos los componentes y sus tipos de interfaz (inputs, outputs).
      2. Dibujar cada componente como una caja con puertos.
      3. Conectar outputs a inputs respetando tipos.
      4. Verificar que no haya ciclos sin delay (o modelar explícitamente el delay).
      5. Definir la interfaz externa: qué inputs/outputs se exponen al exterior.
      6. El resultado es un morfismo en la categoría de wiring diagrams.
    Ref: WIRING-DEF

Monadic_Systems:
  - ID: MONAD-EFFECT
    Def: "Mónada M encapsula un tipo de efecto computacional (fallo, no-determinismo, probabilidad, estado, logging)."
    Catalog:
      - Monad: "Maybe"
        Effect: "Fallo parcial"
        Kleisli: "A → Maybe B"
      - Monad: "List"
        Effect: "No-determinismo"
        Kleisli: "A → [B]"
      - Monad: "Distribution"
        Effect: "Probabilidad"
        Kleisli: "A → D(B)"
      - Monad: "State S"
        Effect: "Estado mutable"
        Kleisli: "A → S → (B,S)"
      - Monad: "Writer W"
        Effect: "Logging/traza"
        Kleisli: "A → (B,W)"

  - ID: KLEISLI-CATEGORY
    Def: "Categoría de Kleisli Kl(M): objetos = tipos, morfismos = funciones A→M(B)."
    Use: "Componer efectos de forma coherente al trabajar con sistemas no puros."
    Ref: MONAD-EFFECT
    Proc: |
      1. Elegir mónada M según el efecto dominante (Maybe, List, State, etc.).
      2. Expresar cada paso del pipeline como f: A→M(B).
      3. Componer usando bind (>>=): f >=> g = λa. (f a) >>= g.
      4. La composición maneja automáticamente el efecto (fallo, no-det, estado).
    Ex: |
      -- Pipeline con Maybe (puede fallar):
      parseUser :: String → Maybe User
      validateAge :: User → Maybe User
      saveUser :: User → Maybe UserId
      -- Composición Kleisli:
      pipeline = parseUser >=> validateAge >=> saveUser
      -- Si cualquier paso falla, todo el pipeline retorna Nothing.

Behavior_Analysis:
  - ID: BEHAVIOR-TRAJECTORY
    Def: "Trayectoria = secuencia de estados generada por la dinámica del sistema."
    Use: "Analizar cómo evoluciona el sistema en el tiempo."

  - ID: BEHAVIOR-STEADY-STATE
    Def: "Estado estacionario: s tal que update(s, i)=s para cierto régimen de inputs."
    Use: "Identificar configuraciones estables del sistema."

  - ID: BEHAVIOR-PERIODIC
    Def: "Órbita periódica: secuencia de estados que se repite tras un número finito de pasos."
    Use: "Modelar ciclos y patrones repetitivos en sistemas dinámicos."
