# KODA Knowledge Artifact: Unified Constraint Logic
# Domain: Category Theory / Sketches / Regular Logic
# Purpose: Unified language for constraints across all artifacts

_manifest:
  urn: "urn:kora:cat:constraint-logic:1.0.0"
  federation:
    visibility: internal
    license: "CC-BY-4.0"
  compatibility:
    min_consumer_version: "1.0.0"
    breaking_changes_from: null
  resolution:
    canonical_url: "file://knowledge/domains/cat/meta/constraint_logic.koda.yml"
    mirrors: []
  dependencies:
    requires:
      - urn: "urn:kora:kb:spec:1.0.0"
      - urn: "urn:kora:cat:seven-sketches:1.0.0"
      - urn: "urn:kora:cat:cql-data-integration:1.0.0"
  provenance:
    created_by: "FS"
    created_at: "2025-12-05"
    last_modified_by: "FS"
    last_modified_at: "2025-12-05"
    signature: null

ID: CAT-CONSTRAINT-01
Version: 1.0.0
Status: Active
Human-Creator: FS
Human-Editor: FS
Model-Collaborator: Cascade
Creation-Date: 2025-12-05
Modification-Date: 2025-12-14
Version-Notes: "Initial KODA/Spec for Unified Constraint Logic."
Ctx: "Lógica unificada de constraints basada en sketches y lógica regular."

LLM_Parsing_Instructions:
  ID: KODA-LLM-PARSER-01
  Req: Mandatory block following Metadata.
  Content: |
    BEGIN_LLM_INSTRUCTIONS
    You are an AI agent consuming a KODA artifact. Parse with absolute fidelity.
    LEXICON (expand before processing): Act->Action, Cond->Condition, Ctx->Context, Ctx_Required->Required External Reference, Ctx_Optional->Optional External Reference, Def->Definition, Ex->Example, Mssn->Mission, Obj->Objective, Proc->Process, Purp->Purpose, Ref->Reference, XRef->Cross-Artifact Reference, XRef_Required->Mandatory Cross-Artifact Reference, Req->Requirement, Res->Result, Src->Source, Prohib->Prohibition, Warn->Warning, Just->Justification, Rec->Recommendation

    REFERENCE POLICY: Ref: internal only. XRef: external URN only.
    END_LLM_INSTRUCTIONS

Purp: "Unificar el lenguaje de constraints para todos los artefactos del KB."
Obj: "Permitir verificación sistemática de satisfacción de teorías."

Sources:
  - Title: "Seven Sketches in Compositionality"
    Authors: ["Fong", "Spivak"]
    Contribution: "Path equations, schemas como categorías."
  - Title: "Categorical Query Language (CQL)"
    Authors: ["Spivak", "Wisnesky"]
    Contribution: "Ologs, constraints como ecuaciones, satisfacción estática."
  - Title: "Sketches of an Elephant"
    Authors: ["Peter Johnstone"]
    Contribution: "Sketches categóricos, lógica regular."

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 1: EL LENGUAJE DE CONSTRAINTS
# ═══════════════════════════════════════════════════════════════════════════

Constraint_Language:
  - ID: CL-LANGUAGE-DEF
    Def: "El lenguaje de constraints L_CT es un fragmento de lógica regular expresable en categorías."
    Components:
      Sorts: "Objetos de la categoría (tipos, entidades)."
      Terms: "Morfismos y sus composiciones (paths)."
      Formulas:
        - ID: FORMULA-PATH-EQ
          Def: "Ecuación de caminos: path₁ = path₂."
          Syntax: "path₁ = path₂ donde path_i es composición de morfismos."
          Semantics: "En toda instancia I: S→Set, I(path₁) = I(path₂) como funciones."
          Ex: "Employee.Mngr.WorksIn = Employee.WorksIn"
        - ID: FORMULA-EXISTENCE
          Def: "Existencia: ∃x. φ(x)."
          Syntax: "Para límites: el objeto límite existe y satisface propiedad universal."
          Semantics: "La categoría tiene el límite requerido."
          Ex: "∃ pullback de A→C←B"
        - ID: FORMULA-UNIQUENESS
          Def: "Unicidad: ∃!x. φ(x)."
          Syntax: "Existe único morfismo satisfaciendo condición."
          Semantics: "Propiedad universal de límites/colímites."
          Ex: "∃! f: X→A×B tal que π₁∘f = g₁ ∧ π₂∘f = g₂"
        - ID: FORMULA-INCLUSION
          Def: "Inclusión: A ↪ B (monomorfismo)."
          Syntax: "Morfismo inyectivo."
          Semantics: "Para toda instancia, I(A) ⊆ I(B) vía I(f) inyectiva."
          Ex: "Manager ↪ Employee (todo manager es empleado)"
        - ID: FORMULA-SURJECTION
          Def: "Cobertura: A ↠ B (epimorfismo)."
          Syntax: "Morfismo sobreyectivo."
          Semantics: "Para toda instancia, I(f): I(A) → I(B) es sobreyectiva."
          Ex: "Employee ↠ HasDepartment (todo empleado tiene departamento)"

  - ID: CL-THEORY-DEF
    Def: "Una teoría T = (S, Σ) donde S es un esquema (categoría) y Σ es conjunto de fórmulas."
    Components:
      Schema: "Categoría S con objetos y morfismos."
      Axioms: "Conjunto Σ de fórmulas en L_CT."
    Ref: FORMULA-PATH-EQ

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 2: SATISFACCIÓN DE TEORÍAS
# ═══════════════════════════════════════════════════════════════════════════

Theory_Satisfaction:
  - ID: CL-SATISFACTION-DEF
    Def: "Una instancia I: S→Set satisface teoría T = (S, Σ) si satisface todas las fórmulas de Σ."
    Notation: "I ⊨ T"
    Proc: |
      1. Para cada φ ∈ Σ:
         a) Si φ es path₁ = path₂: verificar I(path₁) = I(path₂).
         b) Si φ es ∃-fórmula: verificar existencia del objeto requerido.
         c) Si φ es ↪ (mono): verificar inyectividad de I(f).
         d) Si φ es ↠ (epi): verificar sobreyectividad de I(f).
      2. Si todas pasan → I ⊨ T.
      3. Si alguna falla → I ⊭ T, reportar fórmula violada.

  - ID: CL-MODEL-CATEGORY
    Def: "Mod(T) = categoría de modelos de T."
    Structure: |
      - Objetos: Instancias I: S→Set tales que I ⊨ T.
      - Morfismos: Transformaciones naturales α: I ⇒ J que preservan T.
    Use: "Estudiar el espacio de todas las instancias válidas de un esquema con constraints."
    XRef: "urn:kora:cat:mathematical-modelling:1.0.0#MM-MODEL-CATEGORY"

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 3: CONSTRAINTS EN DIFERENTES CONTEXTOS
# ═══════════════════════════════════════════════════════════════════════════

Constraint_Contexts:
  - ID: CL-CONTEXT-DATABASE
    Def: "Constraints de bases de datos expresadas en L_CT."
    Mapping:
      PRIMARY_KEY: "Morfismo desde entidad a tipo singleton (unicidad)."
      FOREIGN_KEY: "Morfismo f: A→B con constraint de existencia en I(B)."
      UNIQUE: "Morfismo que es monomorfismo."
      NOT_NULL: "Morfismo con codominio no-vacío requerido."
      CHECK: "Ecuación de path o inclusión en subobjeto."
    Ex: |
      -- SQL: FOREIGN KEY (dept_id) REFERENCES Department(id)
      -- L_CT: WorksIn: Employee → Department con ∀e. WorksIn(e) ∈ I(Department)

  - ID: CL-CONTEXT-MBSE
    Def: "Constraints de modelos MBSE expresadas en L_CT."
    Mapping:
      Block_Composition: "Diagrama de bloques como categoría, composición = conexión."
      Port_Compatibility: "Ecuación de tipos en puertos conectados."
      Consistency: "Existencia de pullback entre modelos."
    XRef: "urn:kora:cat:mbse-consistency:1.0.0#MBSE-BINARY-CONSISTENCY"

  - ID: CL-CONTEXT-KODA
    Def: "Constraints de artefactos KODA expresadas en L_CT."
    Mapping:
      Ref_Valid: "Morfismo interno bien definido."
      XRef_Resolves: "Morfismo externo con target en KB."
      Proc_Complete: "Existencia de campo Proc para conceptos operativos."
      Version_Match: "Ecuación: metadata.Version = urn.version."

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 4: PRESERVACIÓN DE CONSTRAINTS POR MIGRACIONES
# ═══════════════════════════════════════════════════════════════════════════

Constraint_Preservation:
  - ID: CL-PRESERVATION-DEF
    Def: "Un funtor F: S→T preserva constraint φ si F(φ) es satisfacible en T."
    Types:
      - ID: PRESERVE-STRICT
        Def: "F preserva φ estrictamente si I ⊨ φ ⟹ F*(I) ⊨ F(φ) para todo I."
        Use: "Garantía fuerte: constraint siempre se mantiene."
      - ID: PRESERVE-WEAK
        Def: "F preserva φ débilmente si ∃I tal que F*(I) ⊨ F(φ)."
        Use: "Al menos algunos modelos preservan la constraint."

  - ID: CL-ADJOINT-PRESERVATION
    Def: "Comportamiento de constraints bajo Δ/Σ/Π."
    Rules:
      Delta: |
        Δ_F (pullback) SIEMPRE preserva path equations.
        Razón: Δ_F(I)(A) = I(F(A)), composición se preserva.
      Sigma: |
        Σ_F (left pushforward) NO SIEMPRE preserva constraints.
        Razón: Σ usa colímites, puede "colapsar" distinciones.
        Ejemplo: Si φ dice "A ≠ B" y Σ los identifica, φ se viola.
      Pi: |
        Π_F (right pushforward) preserva constraints de existencia.
        Razón: Π usa límites, preserva propiedades universales.
        Pero puede "vaciar" conjuntos si no hay elementos compatibles.
    Proc: |
      Para verificar preservación de φ por migración F:
      1. Identificar tipo de φ (path eq, mono, epi, existencia).
      2. Identificar operador de migración (Δ, Σ, Π).
      3. Aplicar reglas:
         - Si Δ: preservación garantizada para path eq.
         - Si Σ: verificar que φ no depende de distinciones colapsadas.
         - Si Π: verificar que conjuntos no quedan vacíos.
      4. Documentar qué constraints se preservan y cuáles no.
    XRef: "urn:kora:cat:seven-sketches:1.0.0#MIGRATION-DELTA"

  - ID: CL-MIGRATION-AUDIT
    Def: "Auditar preservación de constraints en una migración."
    Proc: |
      1. Extraer teoría T_source = (S, Σ_S) del esquema fuente.
      2. Extraer teoría T_target = (T, Σ_T) del esquema target.
      3. Identificar funtor F: S → T de la migración.
      4. Para cada φ ∈ Σ_S:
         a) Calcular F(φ) (imagen de la constraint).
         b) Verificar si F(φ) ∈ Σ_T o es derivable de Σ_T.
         c) Si no → WARN: constraint puede perderse.
      5. Para cada ψ ∈ Σ_T que no viene de Σ_S:
         a) Verificar si la migración puede satisfacer ψ.
         b) Si no → ERROR: migración viola constraints del target.
      6. Generar informe de preservación.

# ═══════════════════════════════════════════════════════════════════════════
# SECCIÓN 5: AUDITORÍA DE TEORÍAS
# ═══════════════════════════════════════════════════════════════════════════

Theory_Audit:
  - ID: CL-AUDIT-THEORY
    Def: "Auditar que un artefacto define una teoría consistente."
    Proc: |
      1. EXTRACCIÓN
         a) Identificar esquema S del artefacto.
         b) Extraer constraints explícitas (path eq, FKs, etc.).
         c) Extraer constraints implícitas (de convenciones KODA).
         d) Construir teoría T = (S, Σ).
      
      2. CONSISTENCIA INTERNA
         a) Verificar que Σ no tiene contradicciones obvias.
         b) Ej: path₁ = path₂ y path₁ ≠ path₂ simultáneamente.
         c) Verificar que límites requeridos existen en S.
      
      3. SATISFACIBILIDAD
         a) Verificar que existe al menos un modelo I ⊨ T.
         b) Si T solo tiene modelos vacíos → WARN: teoría posiblemente trivial.
      
      4. COMPLETITUD
         a) Verificar que constraints importantes están declaradas.
         b) Ej: FKs tienen constraint de existencia explícita.
      
      5. REPORTAR
         a) Teoría extraída.
         b) Issues de consistencia.
         c) Issues de completitud.

  - ID: CL-AUDIT-INSTANCE
    Def: "Auditar que una instancia satisface su teoría."
    Proc: |
      1. Cargar esquema S e instancia I.
      2. Cargar teoría T = (S, Σ).
      3. Para cada φ ∈ Σ:
         a) Evaluar I ⊨ φ.
         b) Si falla: registrar violación con datos concretos.
      4. Generar informe de satisfacción.


