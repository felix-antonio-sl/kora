---
_manifest:
  urn: urn:fxsl:kb:seven-sketches
  provenance:
    created_by: FS
    created_at: '2025-12-05'
    source: Seven Sketches in Compositionality - Databases as Functors (Fong, Spivak)
version: 2.0.0
status: published
tags:
- category-theory
- databases
- functorial-data-model
- fdm
- adjunctions
- fxsl
lang: en
---

# Functorial Data Model (FDM)

## Overview

- Chapter introducing database model where schemas are categories, instances are funtores, and migrations are adjoint functors.


- **Core Insight**: Data integration through category-theoretic translation between organizational forms (schema migration).

## Core Definitions

### Database

- System of interlocking tables.
- Data becomes information when stored in given formation.


- **Example**: Employee table with fields (ID, FName, WorksIn, Mngr); Department table (ID, DName, Secr).

- **Business Rules**: Every employee's manager works same department; secretary of department works in department.

### Schema as Category

- **Definition**: Category C finitely presented.

- **Objects**: Entity types (tables).
- **Morfismos**: Relations, attributes, foreign keys.
- **Equations**: Path constraints (business rules).

- **Hasse Diagram**: Black nodes for tables (ID columns); arrows for non-ID columns pointing to references.

### Instance as Funtor

- **Definition**: C-instance is funtor I: C → Set.

- For object X, I(X) = set of rows.
- For morfismo f: X→Y, I(f) = function between sets.

- **Example**: For schema Graph with V, E and morfismos src, tgt: E→V: I(V) = {v1, v2, v3} I(E) = {e1, e2} I(src)(e1) = v1, I(tgt)(e1) = v2

### Category of Instances

- **Definition**: C-Inst := [C, Set] with objects funtores I: C→Set and morfismos natural transformations (instance homomorphisms).

- **Homomorphism**: Natural transformation α: I ⇒ J between instances (structure-preserving mapping).

## Migration Operators

### Δ_F (Pullback/Restriction)

- **Definition**: Given F: C → D and J: D→Set, pullback is Δ_F(J) = J ∘ F.

- **Purpose**: Reindex data from target schema D to source schema C.

- **SQL Analog**: Column renaming, SELECT with alias, table duplication.

- **Guarantee**: Preserves exactly original structure; no information loss.

- **Procedure**:

1. For each object A in source, locate F(A) in target.
2. For instance J on target, define Δ_F(J)(A) := J(F(A)).
3. Composition preserved automatically by functoriality.

### Σ_F (Left Pushforward/Generalization)

- **Definition**: Adjoint left of Δ_F. Migrates from C to D using colimits.

- **Purpose**: Unify and generalize to more general schema.

- **SQL Analog**: UNION, INSERT INTO SELECT, aggregations.

- **Guarantee**: May lose information (co-identifications, fusions); constructs colimits.

- **Property**: If F collapses objects (F(A₁)=F(A₂)=B), data fuse via UNION.

### Π_F (Right Pushforward/Specialization)

- **Definition**: Adjoint right of Δ_F. Migrates from C to D using limits.

- **Purpose**: Specialize imposing joint constraints.

- **SQL Analog**: JOIN, WHERE, cartesian products.

- **Guarantee**: Preserves via products; may discard unmatching records.

- **Property**: For fibra with multiple objects, Π_F calculates product (JOIN); only matching records survive.

### Adjunction Chain

- **Significance**: Σ_F ⊣ Δ_F ⊣ Π_F.
- Every reasonable migration decomposes into combinations of these three.


- **Decision Guide**:

- Δ when: rename/restructure without cardinal change.
- Σ when: fuse, aggregate, generalize (accepts loss).
- Π when: restrict, filter, specialize (accepts discards).

## Limits (Constructions)

### Terminal Object

- **Definition**: 1 in C; for all C∈Ob(C) exists unique morfismo C→1.

- **SQL**: SELECT 1, constants.

- **Use**: Singletons, default values, unit types.

### Product

- **Definition**: A×B with projections π₁, π₂; universal property.

- **SQL**: JOIN cartesian, SELECT a.*, b.*.

- **Use**: Combine independent entities in joint view.

### Pullback

- **Definition**: Fibered product A ×_C B over C.

- **SQL**: JOIN ON shared_key.

- **Use**: Combine entities sharing common context.

### Equalizer

- **Definition**: eq(f,g) = subobjeto where f=g.


- **SQL**: WHERE f(x) = g(x).

- **Use**: Filter records satisfying equality of two paths.

## Colimits (Constructions)

### Initial Object

- **Definition**: 0; for all C exists unique 0→C.

- **SQL**: Empty tables, WHERE FALSE.

- **Use**: Impossible cases.

### Coproduct

- **Definition**: A+B with injections i₁, i₂.

- **SQL**: UNION ALL.

- **Use**: Union entities of same logical type.

### Pushout

- **Definition**: Glued pegado A ⊔_C B identifying common part C.

- **SQL**: UNION + reconciliation of primary keys.

- **Use**: Merge schemas and incremental normalization.

### Coequalizer

- **Definition**: Cociente by equivalence relation generated by two parallel morfismos.

- **SQL**: GROUP BY, DISTINCT.

- **Use**: Collapse duplicates, build equivalence classes.

## Advanced Concepts

### Yoneda Lemma

- **Formula**: Nat(Hom(A,−), F) ≅ F(A) naturally in A.

- **Interpretation**: Object determined completely by how others map toward it.

- **Use**: Interface-oriented design: component known by relations.

- **Application**: Entities defined by foreign-key entries; types by producing functions.

### Kan Extension

- **Left Kan Extension**: Lan_F(G) = best universal approximation extending G along F.

- **Formula**: (Lan_F G)(d) = colim_{c: F(c)→d} G(c).

- **Use**: Generalizes Σ to arbitrary transformations.

### Operational Principles

- **Diagram Commutes**: Model coherent iff all relevant diagrams commute (path₁ = path₂).
- **Universal Property**: Prefer limits/colimits over ad-hoc solutions (canonical and robust).
- **Yoneda Interface**: Design by interfaces; component defined by interactions, not implementation.
