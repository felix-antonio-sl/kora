_manifest:
  urn: "urn:kora:doc:session-management:1.0.0"
  federation:
    visibility: internal
    license: "Proprietary"
  compatibility:
    min_consumer_version: "1.0.0"
    breaking_changes_from: null
  resolution:
    canonical_url: "file://knowledge/domains/moltbot/docs/concepts/kb_session_management.yaml"
    mirrors: []
  provenance:
    created_by: "Moltbot Docs"
    created_at: "2026-01-29"
    last_modified_by: "Codex"
    last_modified_at: "2026-01-29"
    signature: null

ID: MOLTBOT-KB-CONCEPTS-SESSION-MANAGEMENT-01
Version: 1.0.0
Status: Draft
Human-Creator: Moltbot Docs
Human-Editor: Codex
Model-Collaborator: OpenAI-Codex
Creation-Date: '2026-01-29'
Modification-Date: '2026-01-29'
Ctx: 'Moltbot concepts: session management'
LLM_Parsing_Instructions:
  ID: KODA-LLM-PARSER-01
  Req: Mandatory block following Metadata.
  Prohib: Using for artifact creation or translation.
  Content: |-
    BEGIN_LLM_INSTRUCTIONS
    You are an AI agent consuming a KODA artifact. Parse with absolute fidelity.

    FIDELITY: Preserve meat (essential information) and skeleton (structure: headers, IDs, lists, tables) with zero loss. Ignore fat (filler words, rhetoric, stylistic prose).

    LEXICON (expand before processing): Act->Action, Cond->Condition, Ctx->Context, Ctx_Required->Required External Reference, Ctx_Optional->Optional External Reference, Def->Definition, Ex->Example, Mssn->Mission, Obj->Objective, Proc->Process, Purp->Purpose, Ref->Reference, XRef->Cross-Artifact Reference, XRef_Required->Mandatory Cross-Artifact Reference, Req->Requirement, Res->Result, Src->Source, Prohib->Prohibition, Warn->Warning, Just->Justification, Rec->Recommendation

    REFERENCE POLICY: Ref: is internal only—must point to existing ID within THIS document. XRef/XRef_Required: are external only—must point to a URN (optionally with #ID fragment) in another artifact. External documents without specific ID use Ctx:, Ctx_Required:, or Ctx_Optional:.

    LANGUAGE POLICY: Keywords in English, content in original language. Never translate content.
    END_LLM_INSTRUCTIONS
Purp: Session management
Src:
- File: output/concepts/session.md
- File: output/concepts/sessions.md
- File: output/concepts/session-tool.md
- File: output/concepts/session-pruning.md
Sections:
- ID: CONCEPTS-SESSION
  Src:
    File: output/concepts/session.md
    URL: https://docs.molt.bot/concepts/session
  Facts: |-
    H1: Session - Moltbot
    H1: Session
    Session Management
    Moltbot treats **one direct-chat session per agent** as primary. Direct chats collapse to `agent:<agentId>:<mainKey>` (default `main`), while group/channel chats get their own keys. `session.mainKey` is honored. Use `session.dmScope` to control how **direct messages** are grouped:
    - `main` (default): all DMs share the main session for continuity.
    - `per-peer`: isolate by sender id across channels.
    - `per-channel-peer`: isolate by channel + sender (recommended for multi-user inboxes).
    - `per-account-channel-peer`: isolate by account + channel + sender (recommended for multi-account inboxes). Use `session.identityLinks` to map provider-prefixed peer ids to a canonical identity so the same person shares a DM session across channels when using `per-peer`, `per-channel-peer`, or `per-account-channel-peer`.
    Gateway is the source of truth
    All session state is **owned by the gateway** (the "master" Moltbot). UI clients (macOS app, WebChat, etc.) must query the gateway for session lists and token counts instead of reading local files.
    - In **remote mode** , the session store you care about lives on the remote gateway host, not your Mac.
    - Token counts shown in UIs come from the gateway's store fields (`inputTokens`, `outputTokens`, `totalTokens`, `contextTokens`). Clients do not parse JSONL transcripts to "fix up" totals.
    Where state lives
    - On the **gateway host** :
    - Store file: `~/.clawdbot/agents/<agentId>/sessions/sessions.json` (per agent).
    - Transcripts: `~/.clawdbot/agents/<agentId>/sessions/<SessionId>.jsonl` (Telegram topic sessions use `.../<SessionId>-topic-<threadId>.jsonl`).
    - The store is a map `sessionKey -> { sessionId, updatedAt, ... }`. Deleting entries is safe; they are recreated on demand.
    - Group entries may include `displayName`, `channel`, `subject`, `room`, and `space` to label sessions in UIs.
    - Session entries include `origin` metadata (label + routing hints) so UIs can explain where a session came from.
    - Moltbot does **not** read legacy Pi/Tau session folders.
    Session pruning
    Moltbot trims **old tool results** from the in-memory context right before LLM calls by default. This does **not** rewrite JSONL history. See [/concepts/session-pruning](/concepts/session-pruning).
    Pre-compaction memory flush
    When a session nears auto-compaction, Moltbot can run a **silent memory flush** turn that reminds the model to write durable notes to disk. This only runs when the workspace is writable. See [Memory](/concepts/memory) and [Compaction](/concepts/compaction).
    Mapping transports -> session keys
    - Direct chats follow `session.dmScope` (default `main`).
    - `main`: `agent:<agentId>:<mainKey>` (continuity across devices/channels).
    - Multiple phone numbers and channels can map to the same agent main key; they act as transports into one conversation.
    - `per-peer`: `agent:<agentId>:dm:<peerId>`.
    - `per-channel-peer`: `agent:<agentId>:<channel>:dm:<peerId>`.
    - `per-account-channel-peer`: `agent:<agentId>:<channel>:<accountId>:dm:<peerId>` (accountId defaults to `default`).
    - If `session.identityLinks` matches a provider-prefixed peer id (for example `telegram:123`), the canonical key replaces `<peerId>` so the same person shares a session across channels.
    - Group chats isolate state: `agent:<agentId>:<channel>:group:<id>` (rooms/channels use `agent:<agentId>:<channel>:channel:<id>`).
    - Telegram forum topics append `:topic:<threadId>` to the group id for isolation.
    - Legacy `group:<id>` keys are still recognized for migration.
    - Inbound contexts may still use `group:<id>`; the channel is inferred from `Provider` and normalized to the canonical `agent:<agentId>:<channel>:group:<id>` form.
    - Other sources:
    - Cron jobs: `cron:<job.id>`
    - Webhooks: `hook:<uuid>` (unless explicitly set by the hook)
    - Node runs: `node-<nodeId>`
    Lifecycle
    - Reset policy: sessions are reused until they expire, and expiry is evaluated on the next inbound message.
    - Daily reset: defaults to **4:00 AM local time on the gateway host**. A session is stale once its last update is earlier than the most recent daily reset time.
    - Idle reset (optional): `idleMinutes` adds a sliding idle window. When both daily and idle resets are configured, **whichever expires first** forces a new session.
    - Legacy idle-only: if you set `session.idleMinutes` without any `session.reset`/`resetByType` config, Moltbot stays in idle-only mode for backward compatibility.
    - Per-type overrides (optional): `resetByType` lets you override the policy for `dm`, `group`, and `thread` sessions (thread = Slack/Discord threads, Telegram topics, Matrix threads when provided by the connector).
    - Per-channel overrides (optional): `resetByChannel` overrides the reset policy for a channel (applies to all session types for that channel and takes precedence over `reset`/`resetByType`).
    - Reset triggers: exact `/new` or `/reset` (plus any extras in `resetTriggers`) start a fresh session id and pass the remainder of the message through. `/new <model>` accepts a model alias, `provider/model`, or provider name (fuzzy match) to set the new session model. If `/new` or `/reset` is sent alone, Moltbot runs a short "hello" greeting turn to confirm the reset.
    - Manual reset: delete specific keys from the store or remove the JSONL transcript; the next message recreates them.
    - Isolated cron jobs always mint a fresh `sessionId` per run (no idle reuse).
    Send policy (optional)
    Block delivery for specific session types without listing individual ids.
    Runtime override (owner only):
    - `/send on` -> allow for this session
    - `/send off` -> deny for this session
    - `/send inherit` -> clear override and use config rules Send these as standalone messages so they register.
    Configuration (optional rename example)
    Inspecting
    - `moltbot status` - shows store path and recent sessions.
    - `moltbot sessions --json` - dumps every entry (filter with `--active <minutes>`).
    - `moltbot gateway call sessions.list --params '{}'` - fetch sessions from the running gateway (use `--url`/`--token` for remote gateway access).
    - Send `/status` as a standalone message in chat to see whether the agent is reachable, how much of the session context is used, current thinking/verbose toggles, and when your WhatsApp web creds were last refreshed (helps spot relink needs).
    - Send `/context list` or `/context detail` to see what's in the system prompt and injected workspace files (and the biggest context contributors).
    - Send `/stop` as a standalone message to abort the current run, clear queued followups for that session, and stop any sub-agent runs spawned from it (the reply includes the stopped count).
    - Send `/compact` (optional instructions) as a standalone message to summarize older context and free up window space. See [/concepts/compaction](/concepts/compaction).
    - JSONL transcripts can be opened directly to review full turns.
    Tips
    - Keep the primary key dedicated to 1:1 traffic; let groups keep their own keys.
    - When automating cleanup, delete individual keys instead of the whole store to preserve context elsewhere.
    Session origin metadata
    Each session entry records where it came from (best-effort) in `origin`:
    - `label`: human label (resolved from conversation label + group subject/channel)
    - `provider`: normalized channel id (including extensions)
    - `from`/`to`: raw routing ids from the inbound envelope
    - `accountId`: provider account id (when multi-account)
    - `threadId`: thread/topic id when the channel supports it The origin fields are populated for direct messages, channels, and groups. If a connector only updates delivery routing (for example, to keep a DM main session fresh), it should still provide inbound context so the session keeps its explainer metadata. Extensions can do this by sending `ConversationLabel`, `GroupSubject`, `GroupChannel`, `GroupSpace`, and `SenderName` in the inbound context and calling `recordSessionMetaFromInbound` (or passing the same context to `updateLastRoute`).
  Ex:
  - ID: EX-CONCEPTS-SESSION-B351D99C9B
    Ctx: Copy
    Body: |-
      {
      session: {
      sendPolicy: {
      rules: [
      { action: "deny", match: { channel: "discord", chatType: "group" } },
      { action: "deny", match: { keyPrefix: "cron:" } }
      ],
      default: "allow"
      }
      }
      }
  - ID: EX-CONCEPTS-SESSION-996975E64A
    Ctx: Copy
    Body: |-
      // ~/.clawdbot/moltbot.json
      {
      session: {
      scope: "per-sender",      // keep group keys separate
      dmScope: "main",          // DM continuity (set per-channel-peer/per-account-channel-peer for shared inboxes)
      identityLinks: {
      alice: ["telegram:123456789", "discord:987654321012345678"]
      },
      reset: {
      // Defaults: mode=daily, atHour=4 (gateway host local time).
      // If you also set idleMinutes, whichever expires first wins.
      mode: "daily",
      atHour: 4,
      idleMinutes: 120
      },
      resetByType: {
      thread: { mode: "daily", atHour: 4 },
      dm: { mode: "idle", idleMinutes: 240 },
      group: { mode: "idle", idleMinutes: 120 }
      },
      resetByChannel: {
      discord: { mode: "idle", idleMinutes: 10080 }
      },
      resetTriggers: ["/new", "/reset"],
      store: "~/.clawdbot/agents/{agentId}/sessions/sessions.json",
      mainKey: "main",
      }
      }
- ID: CONCEPTS-SESSIONS
  Src:
    File: output/concepts/sessions.md
    URL: https://docs.molt.bot/concepts/sessions
  Facts: |-
    H1: Sessions - Moltbot
    H1: Sessions
    Sessions
    Canonical session management docs live in [Session management](/concepts/session).
- ID: CONCEPTS-SESSION-TOOL
  Src:
    File: output/concepts/session-tool.md
    URL: https://docs.molt.bot/concepts/session-tool
  Facts: |-
    H1: Session tool - Moltbot
    H1: Session tool
    Session Tools
    Goal: small, hard-to-misuse tool set so agents can list sessions, fetch history, and send to another session.
    Tool Names
    - `sessions_list`
    - `sessions_history`
    - `sessions_send`
    - `sessions_spawn`
    Key Model
    - Main direct chat bucket is always the literal key `"main"` (resolved to the current agent's main key).
    - Group chats use `agent:<agentId>:<channel>:group:<id>` or `agent:<agentId>:<channel>:channel:<id>` (pass the full key).
    - Cron jobs use `cron:<job.id>`.
    - Hooks use `hook:<uuid>` unless explicitly set.
    - Node sessions use `node-<nodeId>` unless explicitly set.
    `global` and `unknown` are reserved values and are never listed. If `session.scope = "global"`, we alias it to `main` for all tools so callers never see `global`.
    sessions_list
    List sessions as an array of rows. Parameters:
    - `kinds?: string[]` filter: any of `"main" | "group" | "cron" | "hook" | "node" | "other"`
    - `limit?: number` max rows (default: server default, clamp e.g. 200)
    - `activeMinutes?: number` only sessions updated within N minutes
    - `messageLimit?: number` 0 = no messages (default 0); >0 = include last N messages
    Behavior:
    - `messageLimit > 0` fetches `chat.history` per session and includes the last N messages.
    - Tool results are filtered out in list output; use `sessions_history` for tool messages.
    - When running in a **sandboxed** agent session, session tools default to **spawned-only visibility** (see below).
    Row shape (JSON):
    - `key`: session key (string)
    - `kind`: `main | group | cron | hook | node | other`
    - `channel`: `whatsapp | telegram | discord | signal | imessage | webchat | internal | unknown`
    - `displayName` (group display label if available)
    - `updatedAt` (ms)
    - `sessionId`
    - `model`, `contextTokens`, `totalTokens`
    - `thinkingLevel`, `verboseLevel`, `systemSent`, `abortedLastRun`
    - `sendPolicy` (session override if set)
    - `lastChannel`, `lastTo`
    - `deliveryContext` (normalized `{ channel, to, accountId }` when available)
    - `transcriptPath` (best-effort path derived from store dir + sessionId)
    - `messages?` (only when `messageLimit > 0`)
    sessions_history
    Fetch transcript for one session. Parameters:
    - `sessionKey` (required; accepts session key or `sessionId` from `sessions_list`)
    - `limit?: number` max messages (server clamps)
    - `includeTools?: boolean` (default false)
    Behavior:
    - `includeTools=false` filters `role: "toolResult"` messages.
    - Returns messages array in the raw transcript format.
    - When given a `sessionId`, Moltbot resolves it to the corresponding session key (missing ids error).
    sessions_send
    Send a message into another session. Parameters:
    - `sessionKey` (required; accepts session key or `sessionId` from `sessions_list`)
    - `message` (required)
    - `timeoutSeconds?: number` (default >0; 0 = fire-and-forget)
    Behavior:
    - `timeoutSeconds = 0`: enqueue and return `{ runId, status: "accepted" }`.
    - `timeoutSeconds > 0`: wait up to N seconds for completion, then return `{ runId, status: "ok", reply }`.
    - If wait times out: `{ runId, status: "timeout", error }`. Run continues; call `sessions_history` later.
    - If the run fails: `{ runId, status: "error", error }`.
    - Announce delivery runs after the primary run completes and is best-effort; `status: "ok"` does not guarantee the announce was delivered.
    - Waits via gateway `agent.wait` (server-side) so reconnects don't drop the wait.
    - Agent-to-agent message context is injected for the primary run.
    - After the primary run completes, Moltbot runs a **reply-back loop** :
    - Round 2+ alternates between requester and target agents.
    - Reply exactly `REPLY_SKIP` to stop the pingpong.
    - Max turns is `session.agentToAgent.maxPingPongTurns` (0-5, default 5).
    - Once the loop ends, Moltbot runs the **agenttoagent announce step** (target agent only):
    - Reply exactly `ANNOUNCE_SKIP` to stay silent.
    - Any other reply is sent to the target channel.
    - Announce step includes the original request + round1 reply + latest pingpong reply.
    Channel Field
    - For groups, `channel` is the channel recorded on the session entry.
    - For direct chats, `channel` maps from `lastChannel`.
    - For cron/hook/node, `channel` is `internal`.
    - If missing, `channel` is `unknown`.
    Security / Send Policy
    Policy-based blocking by channel/chat type (not per session id).
    Runtime override (per session entry):
    - `sendPolicy: "allow" | "deny"` (unset = inherit config)
    - Settable via `sessions.patch` or owner-only `/send on|off|inherit` (standalone message).
    Enforcement points:
    - `chat.send` / `agent` (gateway)
    - auto-reply delivery logic
    sessions_spawn
    Spawn a sub-agent run in an isolated session and announce the result back to the requester chat channel. Parameters:
    - `task` (required)
    - `label?` (optional; used for logs/UI)
    - `agentId?` (optional; spawn under another agent id if allowed)
    - `model?` (optional; overrides the sub-agent model; invalid values error)
    - `runTimeoutSeconds?` (default 0; when set, aborts the sub-agent run after N seconds)
    - `cleanup?` (`delete|keep`, default `keep`)
    Allowlist:
    - `agents.list[].subagents.allowAgents`: list of agent ids allowed via `agentId` (`["*"]` to allow any). Default: only the requester agent.
    Discovery:
    - Use `agents_list` to discover which agent ids are allowed for `sessions_spawn`.
    Behavior:
    - Starts a new `agent:<agentId>:subagent:<uuid>` session with `deliver: false`.
    - Sub-agents default to the full tool set **minus session tools** (configurable via `tools.subagents.tools`).
    - Sub-agents are not allowed to call `sessions_spawn` (no sub-agent -> sub-agent spawning).
    - Always non-blocking: returns `{ status: "accepted", runId, childSessionKey }` immediately.
    - After completion, Moltbot runs a sub-agent **announce step** and posts the result to the requester chat channel.
    - Reply exactly `ANNOUNCE_SKIP` during the announce step to stay silent.
    - Announce replies are normalized to `Status`/`Result`/`Notes`; `Status` comes from runtime outcome (not model text).
    - Sub-agent sessions are auto-archived after `agents.defaults.subagents.archiveAfterMinutes` (default: 60).
    - Announce replies include a stats line (runtime, tokens, sessionKey/sessionId, transcript path, and optional cost).
    Sandbox Session Visibility
    Sandboxed sessions can use session tools, but by default they only see sessions they spawned via `sessions_spawn`. Config:
  Ex:
  - ID: EX-CONCEPTS-SESSION-TOOL-A1C2E735AE
    Ctx: Copy
    Body: |-
      {
      "session": {
      "sendPolicy": {
      "rules": [
      {
      "match": { "channel": "discord", "chatType": "group" },
      "action": "deny"
      }
      ],
      "default": "allow"
      }
      }
      }
  - ID: EX-CONCEPTS-SESSION-TOOL-AF09F32FAC
    Ctx: Copy
    Body: |-
      {
      agents: {
      defaults: {
      sandbox: {
      // default: "spawned"
      sessionToolsVisibility: "spawned" // or "all"
      }
      }
      }
      }
- ID: CONCEPTS-SESSION-PRUNING
  Src:
    File: output/concepts/session-pruning.md
    URL: https://docs.molt.bot/concepts/session-pruning
  Facts: |-
    H1: Session pruning - Moltbot
    H1: Session pruning
    Session Pruning
    Session pruning trims **old tool results** from the in-memory context right before each LLM call. It does **not** rewrite the on-disk session history (`*.jsonl`).
    When it runs
    - When `mode: "cache-ttl"` is enabled and the last Anthropic call for the session is older than `ttl`.
    - Only affects the messages sent to the model for that request.
    - Only active for Anthropic API calls (and OpenRouter Anthropic models).
    - For best results, match `ttl` to your model `cacheControlTtl`.
    - After a prune, the TTL window resets so subsequent requests keep cache until `ttl` expires again.
    Smart defaults (Anthropic)
    - **OAuth or setup-token** profiles: enable `cache-ttl` pruning and set heartbeat to `1h`.
    - **API key** profiles: enable `cache-ttl` pruning, set heartbeat to `30m`, and default `cacheControlTtl` to `1h` on Anthropic models.
    - If you set any of these values explicitly, Moltbot does **not** override them.
    What this improves (cost + cache behavior)
    - **Why prune:** Anthropic prompt caching only applies within the TTL. If a session goes idle past the TTL, the next request re-caches the full prompt unless you trim it first.
    - **What gets cheaper:** pruning reduces the **cacheWrite** size for that first request after the TTL expires.
    - **Why the TTL reset matters:** once pruning runs, the cache window resets, so followup requests can reuse the freshly cached prompt instead of re-caching the full history again.
    - **What it does not do:** pruning doesn't add tokens or "double" costs; it only changes what gets cached on that first postTTL request.
    What can be pruned
    - Only `toolResult` messages.
    - User + assistant messages are **never** modified.
    - The last `keepLastAssistants` assistant messages are protected; tool results after that cutoff are not pruned.
    - If there aren't enough assistant messages to establish the cutoff, pruning is skipped.
    - Tool results containing **image blocks** are skipped (never trimmed/cleared).
    Context window estimation
    Pruning uses an estimated context window (chars  tokens  4). The window size is resolved in this order:
    - Model definition `contextWindow` (from the model registry).
    - `models.providers.*.models[].contextWindow` override.
    - `agents.defaults.contextTokens`.
    - Default `200000` tokens.
    Mode
    cache-ttl
    - Pruning only runs if the last Anthropic call is older than `ttl` (default `5m`).
    - When it runs: same soft-trim + hard-clear behavior as before.
    Soft vs hard pruning
    - **Soft-trim** : only for oversized tool results.
    - Keeps head + tail, inserts `...`, and appends a note with the original size.
    - Skips results with image blocks.
    - **Hard-clear** : replaces the entire tool result with `hardClear.placeholder`.
    Tool selection
    - `tools.allow` / `tools.deny` support `*` wildcards.
    - Deny wins.
    - Matching is case-insensitive.
    - Empty allow list => all tools allowed.
    Interaction with other limits
    - Built-in tools already truncate their own output; session pruning is an extra layer that prevents long-running chats from accumulating too much tool output in the model context.
    - Compaction is separate: compaction summarizes and persists, pruning is transient per request. See [/concepts/compaction](/concepts/compaction).
    Defaults (when enabled)
    - `ttl`: `"5m"`
    - `keepLastAssistants`: `3`
    - `softTrimRatio`: `0.3`
    - `hardClearRatio`: `0.5`
    - `minPrunableToolChars`: `50000`
    - `softTrim`: `{ maxChars: 4000, headChars: 1500, tailChars: 1500 }`
    - `hardClear`: `{ enabled: true, placeholder: "[Old tool result content cleared]" }`
    Examples
    Default (off):
    Enable TTL-aware pruning:
    Restrict pruning to specific tools:
    See config reference: [Gateway Configuration](/gateway/configuration)
  Ex:
  - ID: EX-CONCEPTS-SESSION-PRUNING-5684F80F27
    Ctx: Copy
    Body: |-
      {
      agent: {
      contextPruning: { mode: "off" }
      }
      }
  - ID: EX-CONCEPTS-SESSION-PRUNING-E53A85D31B
    Ctx: Copy
    Body: |-
      {
      agent: {
      contextPruning: { mode: "cache-ttl", ttl: "5m" }
      }
      }
  - ID: EX-CONCEPTS-SESSION-PRUNING-A3D0541F2A
    Ctx: Copy
    Body: |-
      {
      agent: {
      contextPruning: {
      mode: "cache-ttl",
      tools: { allow: ["exec", "read"], deny: ["*image*"] }
      }
      }
      }
