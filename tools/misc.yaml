_manifest:
  urn: "urn:kora:doc:misc:1.0.0"
  federation:
    visibility: internal
    license: "Proprietary"
  compatibility:
    min_consumer_version: "1.0.0"
    breaking_changes_from: null
  resolution:
    canonical_url: "file://knowledge/domains/moltbot/docs/concepts/kb_misc.yaml"
    mirrors: []
  provenance:
    created_by: "Moltbot Docs"
    created_at: "2026-01-29"
    last_modified_by: "Codex"
    last_modified_at: "2026-01-29"
    signature: null

ID: MOLTBOT-KB-CONCEPTS-MISC-01
Version: 1.0.0
Status: Draft
Human-Creator: Moltbot Docs
Human-Editor: Codex
Model-Collaborator: OpenAI-Codex
Creation-Date: '2026-01-29'
Modification-Date: '2026-01-29'
Ctx: 'Moltbot concepts: misc'
LLM_Parsing_Instructions:
  ID: KODA-LLM-PARSER-01
  Req: Mandatory block following Metadata.
  Prohib: Using for artifact creation or translation.
  Content: |-
    BEGIN_LLM_INSTRUCTIONS
    You are an AI agent consuming a KODA artifact. Parse with absolute fidelity.

    FIDELITY: Preserve meat (essential information) and skeleton (structure: headers, IDs, lists, tables) with zero loss. Ignore fat (filler words, rhetoric, stylistic prose).

    LEXICON (expand before processing): Act->Action, Cond->Condition, Ctx->Context, Ctx_Required->Required External Reference, Ctx_Optional->Optional External Reference, Def->Definition, Ex->Example, Mssn->Mission, Obj->Objective, Proc->Process, Purp->Purpose, Ref->Reference, XRef->Cross-Artifact Reference, XRef_Required->Mandatory Cross-Artifact Reference, Req->Requirement, Res->Result, Src->Source, Prohib->Prohibition, Warn->Warning, Just->Justification, Rec->Recommendation

    REFERENCE POLICY: Ref: is internal only—must point to existing ID within THIS document. XRef/XRef_Required: are external only—must point to a URN (optionally with #ID fragment) in another artifact. External documents without specific ID use Ctx:, Ctx_Required:, or Ctx_Optional:.

    LANGUAGE POLICY: Keywords in English, content in original language. Never translate content.
    END_LLM_INSTRUCTIONS
Purp: Misc concepts
Src:
- File: output/concepts/oauth.md
- File: output/concepts/timezone.md
- File: output/concepts/typebox.md
- File: output/concepts/usage-tracking.md
- File: output/concepts/architecture.md
Sections:
- ID: CONCEPTS-OAUTH
  Src:
    File: output/concepts/oauth.md
    URL: https://docs.molt.bot/concepts/oauth
  Facts: |-
    H1: Oauth - Moltbot
    H1: Oauth
    OAuth
    Moltbot supports "subscription auth" via OAuth for providers that offer it (notably **OpenAI Codex (ChatGPT OAuth)**). For Anthropic subscriptions, use the **setup-token** flow. This page explains:
    - how the OAuth **token exchange** works (PKCE)
    - where tokens are **stored** (and why)
    - how to handle **multiple accounts** (profiles + per-session overrides)
    Moltbot also supports **provider plugins** that ship their own OAuth or APIkey flows. Run them via:
    The token sink (why it exists)
    OAuth providers commonly mint a **new refresh token** during login/refresh flows. Some providers (or OAuth clients) can invalidate older refresh tokens when a new one is issued for the same user/app. Practical symptom:
    - you log in via Moltbot _and_ via Claude Code / Codex CLI -> one of them randomly gets "logged out" later
    To reduce that, Moltbot treats `auth-profiles.json` as a **token sink** :
    - the runtime reads credentials from **one place**
    - we can keep multiple profiles and route them deterministically
    Storage (where tokens live)
    Secrets are stored **per-agent** :
    - Auth profiles (OAuth + API keys): `~/.clawdbot/agents/<agentId>/agent/auth-profiles.json`
    - Runtime cache (managed automatically; don't edit): `~/.clawdbot/agents/<agentId>/agent/auth.json`
    Legacy import-only file (still supported, but not the main store):
    - `~/.clawdbot/credentials/oauth.json` (imported into `auth-profiles.json` on first use)
    All of the above also respect `$CLAWDBOT_STATE_DIR` (state dir override). Full reference: [/gateway/configuration](/gateway/configuration#auth-storage-oauth--api-keys)
    Anthropic setup-token (subscription auth)
    Run `claude setup-token` on any machine, then paste it into Moltbot:
    If you generated the token elsewhere, paste it manually:
    Verify:
    OAuth exchange (how login works)
    Moltbot's interactive login flows are implemented in `@mariozechner/pi-ai` and wired into the wizards/commands.
    Anthropic (Claude Pro/Max) setup-token
    Flow shape:
    - run `claude setup-token`
    - paste the token into Moltbot
    - store as a token auth profile (no refresh)
    The wizard path is `moltbot onboard` -> auth choice `setup-token` (Anthropic).
    OpenAI Codex (ChatGPT OAuth)
    Flow shape (PKCE):
    - generate PKCE verifier/challenge + random `state`
    - open `https://auth.openai.com/oauth/authorize?...`
    - try to capture callback on `http://127.0.0.1:1455/auth/callback`
    - if callback can't bind (or you're remote/headless), paste the redirect URL/code
    - exchange at `https://auth.openai.com/oauth/token`
    - extract `accountId` from the access token and store `{ access, refresh, expires, accountId }`
    Wizard path is `moltbot onboard` -> auth choice `openai-codex`.
    Refresh + expiry
    Profiles store an `expires` timestamp. At runtime:
    - if `expires` is in the future -> use the stored access token
    - if expired -> refresh (under a file lock) and overwrite the stored credentials
    The refresh flow is automatic; you generally don't need to manage tokens manually.
    Multiple accounts (profiles) + routing
    Two patterns:
    1) Preferred: separate agents
    If you want "personal" and "work" to never interact, use isolated agents (separate sessions + credentials + workspace):
    Then configure auth per-agent (wizard) and route chats to the right agent.
    2) Advanced: multiple profiles in one agent
    `auth-profiles.json` supports multiple profile IDs for the same provider. Pick which profile is used:
    - globally via config ordering (`auth.order`)
    - per-session via `/model ...@<profileId>`
    Example (session override):
    - `/model Opus@anthropic:work`
    How to see what profile IDs exist:
    - `moltbot channels list --json` (shows `auth[]`)
    Related docs:
    - [/concepts/model-failover](/concepts/model-failover) (rotation + cooldown rules)
    - [/tools/slash-commands](/tools/slash-commands) (command surface)
  Ex:
  - ID: EX-CONCEPTS-OAUTH-3F93B73904
    Ctx: Copy
    Body: moltbot models auth login --provider <id>
  - ID: EX-CONCEPTS-OAUTH-CD88CA6FA5
    Ctx: Copy
    Body: moltbot models auth setup-token --provider anthropic
  - ID: EX-CONCEPTS-OAUTH-F31D8BF1ED
    Ctx: Copy
    Body: moltbot models auth paste-token --provider anthropic
  - ID: EX-CONCEPTS-OAUTH-68E06FE0AE
    Ctx: Copy
    Body: moltbot models status
  - ID: EX-CONCEPTS-OAUTH-3078766BAA
    Ctx: Copy
    Body: |-
      moltbot agents add work
      moltbot agents add personal
- ID: CONCEPTS-TIMEZONE
  Src:
    File: output/concepts/timezone.md
    URL: https://docs.molt.bot/concepts/timezone
  Facts: |-
    H1: Timezone - Moltbot
    H1: Timezone
    Timezones
    Moltbot standardizes timestamps so the model sees a **single reference time**.
    Message envelopes (local by default)
    Inbound messages are wrapped in an envelope like:
    The timestamp in the envelope is **host-local by default** , with minutes precision. You can override this with:
    - `envelopeTimezone: "utc"` uses UTC.
    - `envelopeTimezone: "user"` uses `agents.defaults.userTimezone` (falls back to host timezone).
    - Use an explicit IANA timezone (e.g., `"Europe/Vienna"`) for a fixed offset.
    - `envelopeTimestamp: "off"` removes absolute timestamps from envelope headers.
    - `envelopeElapsed: "off"` removes elapsed time suffixes (the `+2m` style).
    Examples
    **Local (default):**
    **Fixed timezone:**
    **Elapsed time:**
    Tool payloads (raw provider data + normalized fields)
    Tool calls (`channels.discord.readMessages`, `channels.slack.readMessages`, etc.) return **raw provider timestamps**. We also attach normalized fields for consistency:
    - `timestampMs` (UTC epoch milliseconds)
    - `timestampUtc` (ISO 8601 UTC string)
    Raw provider fields are preserved.
    User timezone for the system prompt
    Set `agents.defaults.userTimezone` to tell the model the user's local time zone. If it is unset, Moltbot resolves the **host timezone at runtime** (no config write).
    The system prompt includes:
    - `Current Date & Time` section with local time and timezone
    - `Time format: 12-hour` or `24-hour`
    You can control the prompt format with `agents.defaults.timeFormat` (`auto` | `12` | `24`). See [Date & Time](/date-time) for the full behavior and examples.
  Ex:
  - ID: EX-CONCEPTS-TIMEZONE-CC8A1B9DDB
    Ctx: Copy
    Body: '[Provider ... 2026-01-05 16:26 PST] message text'
  - ID: EX-CONCEPTS-TIMEZONE-3EA6ADD651
    Ctx: Copy
    Body: |-
      {
      agents: {
      defaults: {
      envelopeTimezone: "local", // "utc" | "local" | "user" | IANA timezone
      envelopeTimestamp: "on", // "on" | "off"
      envelopeElapsed: "on" // "on" | "off"
      }
      }
      }
  - ID: EX-CONCEPTS-TIMEZONE-75E709E371
    Ctx: Copy
    Body: '[Signal Alice +1555 2026-01-18 00:19 PST] hello'
  - ID: EX-CONCEPTS-TIMEZONE-D8214B0049
    Ctx: Copy
    Body: '[Signal Alice +1555 2026-01-18 06:19 GMT+1] hello'
  - ID: EX-CONCEPTS-TIMEZONE-4211706F13
    Ctx: Copy
    Body: '[Signal Alice +1555 +2m 2026-01-18T05:19Z] follow-up'
  - ID: EX-CONCEPTS-TIMEZONE-7694B6D02F
    Ctx: Copy
    Body: |-
      {
      agents: { defaults: { userTimezone: "America/Chicago" } }
      }
- ID: CONCEPTS-TYPEBOX
  Src:
    File: output/concepts/typebox.md
    URL: https://docs.molt.bot/concepts/typebox
  Facts: |-
    H1: Typebox - Moltbot
    H1: Typebox
    TypeBox as protocol source of truth
    Last updated: 2026-01-10 TypeBox is a TypeScript-first schema library. We use it to define the **Gateway WebSocket protocol** (handshake, request/response, server events). Those schemas drive **runtime validation** , **JSON Schema export** , and **Swift codegen** for the macOS app. One source of truth; everything else is generated. If you want the higher-level protocol context, start with [Gateway architecture](/concepts/architecture).
    Mental model (30 seconds)
    Every Gateway WS message is one of three frames:
    - **Request** : `{ type: "req", id, method, params }`
    - **Response** : `{ type: "res", id, ok, payload | error }`
    - **Event** : `{ type: "event", event, payload, seq?, stateVersion? }`
    The first frame **must** be a `connect` request. After that, clients can call methods (e.g. `health`, `send`, `chat.send`) and subscribe to events (e.g. `presence`, `tick`, `agent`). Connection flow (minimal):
    Common methods + events:
    Authoritative list lives in `src/gateway/server.ts` (`METHODS`, `EVENTS`).
    Where the schemas live
    - Source: `src/gateway/protocol/schema.ts`
    - Runtime validators (AJV): `src/gateway/protocol/index.ts`
    - Server handshake + method dispatch: `src/gateway/server.ts`
    - Node client: `src/gateway/client.ts`
    - Generated JSON Schema: `dist/protocol.schema.json`
    - Generated Swift models: `apps/macos/Sources/MoltbotProtocol/GatewayModels.swift`
    Current pipeline
    - `pnpm protocol:gen`
    - writes JSON Schema (draft07) to `dist/protocol.schema.json`
    - `pnpm protocol:gen:swift`
    - generates Swift gateway models
    - `pnpm protocol:check`
    - runs both generators and verifies the output is committed
    How the schemas are used at runtime
    - **Server side** : every inbound frame is validated with AJV. The handshake only accepts a `connect` request whose params match `ConnectParams`.
    - **Client side** : the JS client validates event and response frames before using them.
    - **Method surface** : the Gateway advertises the supported `methods` and `events` in `hello-ok`.
    Example frames
    Connect (first message):
    Hello-ok response:
    Request + response:
    Event:
    Minimal client (Node.js)
    Smallest useful flow: connect + health.
    Worked example: add a method endtoend
    Example: add a new `system.echo` request that returns `{ ok: true, text }`.
    - **Schema (source of truth)**
    Add to `src/gateway/protocol/schema.ts`:
    Add both to `ProtocolSchemas` and export types:
    - **Validation**
    In `src/gateway/protocol/index.ts`, export an AJV validator:
    - **Server behavior**
    Add a handler in `src/gateway/server-methods/system.ts`:
    Register it in `src/gateway/server-methods.ts` (already merges `systemHandlers`), then add `"system.echo"` to `METHODS` in `src/gateway/server.ts`.
    - **Regenerate**
    - **Tests + docs**
    Add a server test in `src/gateway/server.*.test.ts` and note the method in docs.
    Swift codegen behavior
    The Swift generator emits:
    - `GatewayFrame` enum with `req`, `res`, `event`, and `unknown` cases
    - Strongly typed payload structs/enums
    - `ErrorCode` values and `GATEWAY_PROTOCOL_VERSION`
    Unknown frame types are preserved as raw payloads for forward compatibility.
    Versioning + compatibility
    - `PROTOCOL_VERSION` lives in `src/gateway/protocol/schema.ts`.
    - Clients send `minProtocol` \+ `maxProtocol`; the server rejects mismatches.
    - The Swift models keep unknown frame types to avoid breaking older clients.
    Schema patterns and conventions
    - Most objects use `additionalProperties: false` for strict payloads.
    - `NonEmptyString` is the default for IDs and method/event names.
    - The top-level `GatewayFrame` uses a **discriminator** on `type`.
    - Methods with side effects usually require an `idempotencyKey` in params (example: `send`, `poll`, `agent`, `chat.send`).
    Live schema JSON
    Generated JSON Schema is in the repo at `dist/protocol.schema.json`. The published raw file is typically available at:
    - <https://raw.githubusercontent.com/moltbot/moltbot/main/dist/protocol.schema.json>
    When you change schemas
    - Update the TypeBox schemas.
    - Run `pnpm protocol:check`.
    - Commit the regenerated schema + Swift models.
  Tables: |-
    Category| Examples| Notes
    ---|---|---
    Core| `connect`, `health`, `status`| `connect` must be first
    Messaging| `send`, `poll`, `agent`, `agent.wait`| side-effects need `idempotencyKey`
    Chat| `chat.history`, `chat.send`, `chat.abort`, `chat.inject`| WebChat uses these
    Sessions| `sessions.list`, `sessions.patch`, `sessions.delete`| session admin
    Nodes| `node.list`, `node.invoke`, `node.pair.*`| Gateway WS + node actions
    Events| `tick`, `presence`, `agent`, `chat`, `health`, `shutdown`| server push
  Ex:
  - ID: EX-CONCEPTS-TYPEBOX-901A53A23C
    Ctx: Copy
    Body: |-
      Client                    Gateway
      |---- req:connect -------->|
      |<---- res:hello-ok --------|
      |<---- event:tick ----------|
      |---- req:health ---------->|
      |<---- res:health ----------|
  - ID: EX-CONCEPTS-TYPEBOX-41BE641A71
    Ctx: Copy
    Body: |-
      {
      "type": "req",
      "id": "c1",
      "method": "connect",
      "params": {
      "minProtocol": 2,
      "maxProtocol": 2,
      "client": {
      "id": "moltbot-macos",
      "displayName": "macos",
      "version": "1.0.0",
      "platform": "macos 15.1",
      "mode": "ui",
      "instanceId": "A1B2"
      }
      }
      }
  - ID: EX-CONCEPTS-TYPEBOX-CDDE2FFDE4
    Ctx: Copy
    Body: |-
      {
      "type": "res",
      "id": "c1",
      "ok": true,
      "payload": {
      "type": "hello-ok",
      "protocol": 2,
      "server": { "version": "dev", "connId": "ws-1" },
      "features": { "methods": ["health"], "events": ["tick"] },
      "snapshot": { "presence": [], "health": {}, "stateVersion": { "presence": 0, "health": 0 }, "uptimeMs": 0 },
      "policy": { "maxPayload": 1048576, "maxBufferedBytes": 1048576, "tickIntervalMs": 30000 }
      }
      }
  - ID: EX-CONCEPTS-TYPEBOX-FBB13E6335
    Ctx: Copy
    Body: '{ "type": "req", "id": "r1", "method": "health" }'
  - ID: EX-CONCEPTS-TYPEBOX-1CEFA9535F
    Ctx: Copy
    Body: '{ "type": "res", "id": "r1", "ok": true, "payload": { "ok": true } }'
  - ID: EX-CONCEPTS-TYPEBOX-83D4C1A7FC
    Ctx: Copy
    Body: '{ "type": "event", "event": "tick", "payload": { "ts": 1730000000 }, "seq": 12 }'
  - ID: EX-CONCEPTS-TYPEBOX-8EE1AE2A7C
    Ctx: Copy
    Body: import { WebSocket } from "ws";
  - ID: EX-CONCEPTS-TYPEBOX-756A05C363
    Body: const ws = new WebSocket("ws://127.0.0.1:18789");
  - ID: EX-CONCEPTS-TYPEBOX-DCE18BADCA
    Body: |-
      ws.on("open", () => {
      ws.send(JSON.stringify({
      type: "req",
      id: "c1",
      method: "connect",
      params: {
      minProtocol: 3,
      maxProtocol: 3,
      client: {
      id: "cli",
      displayName: "example",
      version: "dev",
      platform: "node",
      mode: "cli"
      }
      }
      }));
      });
  - ID: EX-CONCEPTS-TYPEBOX-6AF0E2E2AE
    Body: |-
      ws.on("message", (data) => {
      const msg = JSON.parse(String(data));
      if (msg.type === "res" && msg.id === "c1" && msg.ok) {
      ws.send(JSON.stringify({ type: "req", id: "h1", method: "health" }));
      }
      if (msg.type === "res" && msg.id === "h1") {
      console.log("health:", msg.payload);
      ws.close();
      }
      });
  - ID: EX-CONCEPTS-TYPEBOX-FD221CC9AD
    Ctx: Copy
    Body: |-
      export const SystemEchoParamsSchema = Type.Object(
      { text: NonEmptyString },
      { additionalProperties: false },
      );
  - ID: EX-CONCEPTS-TYPEBOX-F1A42DBE79
    Body: |-
      export const SystemEchoResultSchema = Type.Object(
      { ok: Type.Boolean(), text: NonEmptyString },
      { additionalProperties: false },
      );
  - ID: EX-CONCEPTS-TYPEBOX-08E1A2A84E
    Ctx: Copy
    Body: |-
      SystemEchoParams: SystemEchoParamsSchema,
      SystemEchoResult: SystemEchoResultSchema,
  - ID: EX-CONCEPTS-TYPEBOX-24FB4AC757
    Ctx: Copy
    Body: |-
      export type SystemEchoParams = Static<typeof SystemEchoParamsSchema>;
      export type SystemEchoResult = Static<typeof SystemEchoResultSchema>;
  - ID: EX-CONCEPTS-TYPEBOX-8134841466
    Ctx: Copy
    Body: |-
      export const validateSystemEchoParams =
      ajv.compile<SystemEchoParams>(SystemEchoParamsSchema);
  - ID: EX-CONCEPTS-TYPEBOX-5B6F69072B
    Ctx: Copy
    Body: |-
      export const systemHandlers: GatewayRequestHandlers = {
      "system.echo": ({ params, respond }) => {
      const text = String(params.text ?? "");
      respond(true, { ok: true, text });
      },
      };
  - ID: EX-CONCEPTS-TYPEBOX-38BD655E38
    Ctx: Copy
    Body: pnpm protocol:check
- ID: CONCEPTS-USAGE-TRACKING
  Src:
    File: output/concepts/usage-tracking.md
    URL: https://docs.molt.bot/concepts/usage-tracking
  Facts: |-
    H1: Usage tracking - Moltbot
    H1: Usage tracking
    Usage tracking
    What it is
    - Pulls provider usage/quota directly from their usage endpoints.
    - No estimated costs; only the provider-reported windows.
    Where it shows up
    - `/status` in chats: emojirich status card with session tokens + estimated cost (API key only). Provider usage shows for the **current model provider** when available.
    - `/usage off|tokens|full` in chats: per-response usage footer (OAuth shows tokens only).
    - `/usage cost` in chats: local cost summary aggregated from Moltbot session logs.
    - CLI: `moltbot status --usage` prints a full per-provider breakdown.
    - CLI: `moltbot channels list` prints the same usage snapshot alongside provider config (use `--no-usage` to skip).
    - macOS menu bar: "Usage" section under Context (only if available).
    Providers + credentials
    - **Anthropic (Claude)** : OAuth tokens in auth profiles.
    - **GitHub Copilot** : OAuth tokens in auth profiles.
    - **Gemini CLI** : OAuth tokens in auth profiles.
    - **Antigravity** : OAuth tokens in auth profiles.
    - **OpenAI Codex** : OAuth tokens in auth profiles (accountId used when present).
    - **MiniMax** : API key (coding plan key; `MINIMAX_CODE_PLAN_KEY` or `MINIMAX_API_KEY`); uses the 5hour coding plan window.
    - **z.ai** : API key via env/config/auth store.
    Usage is hidden if no matching OAuth/API credentials exist.
- ID: CONCEPTS-ARCHITECTURE
  Src:
    File: output/concepts/architecture.md
    URL: https://docs.molt.bot/concepts/architecture
  Facts: |-
    H1: Architecture - Moltbot
    H1: Architecture
    Gateway architecture
    Last updated: 2026-01-22
    Overview
    - A single longlived **Gateway** owns all messaging surfaces (WhatsApp via Baileys, Telegram via grammY, Slack, Discord, Signal, iMessage, WebChat).
    - Control-plane clients (macOS app, CLI, web UI, automations) connect to the Gateway over **WebSocket** on the configured bind host (default `127.0.0.1:18789`).
    - **Nodes** (macOS/iOS/Android/headless) also connect over **WebSocket** , but declare `role: node` with explicit caps/commands.
    - One Gateway per host; it is the only place that opens a WhatsApp session.
    - A **canvas host** (default `18793`) serves agenteditable HTML and A2UI.
    Components and flows
    Gateway (daemon)
    - Maintains provider connections.
    - Exposes a typed WS API (requests, responses, serverpush events).
    - Validates inbound frames against JSON Schema.
    - Emits events like `agent`, `chat`, `presence`, `health`, `heartbeat`, `cron`.
    Clients (mac app / CLI / web admin)
    - One WS connection per client.
    - Send requests (`health`, `status`, `send`, `agent`, `system-presence`).
    - Subscribe to events (`tick`, `agent`, `presence`, `shutdown`).
    Nodes (macOS / iOS / Android / headless)
    - Connect to the **same WS server** with `role: node`.
    - Provide a device identity in `connect`; pairing is **devicebased** (role `node`) and approval lives in the device pairing store.
    - Expose commands like `canvas.*`, `camera.*`, `screen.record`, `location.get`.
    Protocol details:
    - [Gateway protocol](/gateway/protocol)
    WebChat
    - Static UI that uses the Gateway WS API for chat history and sends.
    - In remote setups, connects through the same SSH/Tailscale tunnel as other clients.
    Connection lifecycle (single client)
    Wire protocol (summary)
    - Transport: WebSocket, text frames with JSON payloads.
    - First frame **must** be `connect`.
    - After handshake:
    - Requests: `{type:"req", id, method, params}` -> `{type:"res", id, ok, payload|error}`
    - Events: `{type:"event", event, payload, seq?, stateVersion?}`
    - If `CLAWDBOT_GATEWAY_TOKEN` (or `--token`) is set, `connect.params.auth.token` must match or the socket closes.
    - Idempotency keys are required for sideeffecting methods (`send`, `agent`) to safely retry; the server keeps a shortlived dedupe cache.
    - Nodes must include `role: "node"` plus caps/commands/permissions in `connect`.
    Pairing + local trust
    - All WS clients (operators + nodes) include a **device identity** on `connect`.
    - New device IDs require pairing approval; the Gateway issues a **device token** for subsequent connects.
    - **Local** connects (loopback or the gateway host's own tailnet address) can be autoapproved to keep samehost UX smooth.
    - **Nonlocal** connects must sign the `connect.challenge` nonce and require explicit approval.
    - Gateway auth (`gateway.auth.*`) still applies to **all** connections, local or remote.
    Details: [Gateway protocol](/gateway/protocol), [Pairing](/start/pairing), [Security](/gateway/security).
    Protocol typing and codegen
    - TypeBox schemas define the protocol.
    - JSON Schema is generated from those schemas.
    - Swift models are generated from the JSON Schema.
    Remote access
    - Preferred: Tailscale or VPN.
    - Alternative: SSH tunnel
    - The same handshake + auth token apply over the tunnel.
    - TLS + optional pinning can be enabled for WS in remote setups.
    Operations snapshot
    - Start: `moltbot gateway` (foreground, logs to stdout).
    - Health: `health` over WS (also included in `hello-ok`).
    - Supervision: launchd/systemd for autorestart.
    Invariants
    - Exactly one Gateway controls a single Baileys session per host.
    - Handshake is mandatory; any nonJSON or nonconnect first frame is a hard close.
    - Events are not replayed; clients must refresh on gaps.
  Ex:
  - ID: EX-CONCEPTS-ARCHITECTURE-CF3EA14CD0
    Ctx: Copy
    Body: |-
      Client                    Gateway
      |                          |
      |---- req:connect -------->|
      |<------ res (ok) ---------|   (or res error + close)
      |   (payload=hello-ok carries snapshot: presence + health)
      |                          |
      |<------ event:presence ---|
      |<------ event:tick -------|
      |                          |
      |------- req:agent ------->|
      |<------ res:agent --------|   (ack: {runId,status:"accepted"})
      |<------ event:agent ------|   (streaming)
      |<------ res:agent --------|   (final: {runId,status,summary})
      |                          |
  - ID: EX-CONCEPTS-ARCHITECTURE-C2116CED28
    Ctx: Copy
    Body: ssh -N -L 18789:127.0.0.1:18789 user@host
