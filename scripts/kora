#!/usr/bin/env python3
"""
KORA CLI v2.0
The official command-line interface for the Kora Monorepo.
Commands:
  index    - Dynamically rebuilds catalog_master_kora.yml
  resolve  - Finds the physical path of a URN
  health   - Checks for broken URN links in the monorepo
  validate - Validates agents against KORA/Agent schemas
"""

import os
import sys
import re
import argparse
import yaml
from pathlib import Path

KORA_ROOT = Path(os.path.abspath(__file__)).parent.parent
CATALOG_PATH = KORA_ROOT / "catalog" / "catalog_master_kora.yml"
SCHEMA_PATH = KORA_ROOT / "schemas" / "kora-agent-schema.json"


def load_yaml_safe(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            content = f.read()

        # For .md files, extract YAML frontmatter between --- delimiters
        if path.suffix == ".md":
            if content.startswith("---"):
                end = content.index("---", 3)
                frontmatter = content[3:end]
                doc = yaml.safe_load(frontmatter)
                # Attach body for title extraction
                if isinstance(doc, dict):
                    doc["_md_body"] = content[end + 3 :].strip()
                return doc, None
            return None, "No YAML frontmatter found"

        # For YAML files, parse normally
        try:
            return yaml.safe_load(content), None
        except yaml.composer.ComposerError:
            docs = list(yaml.safe_load_all(content))
            if docs:
                return docs[0], None
            return None, "Empty multi-document"
    except Exception as e:
        return None, str(e)


def get_artifact_title(doc, file_path):
    # Try to find a human readable title
    if not isinstance(doc, dict):
        return file_path.name

    # For MD files, extract H1 title from body
    body = doc.pop("_md_body", "")
    if body:
        for line in body.split("\n"):
            line = line.strip()
            if line.startswith("# ") and not line.startswith("## "):
                return line[2:].strip()

    if "ID" in doc:
        return str(doc["ID"])

    try:
        return doc["agent_identity_and_global_configuration"][
            "primary_role_objective_and_audience"
        ]["role"]
    except (KeyError, TypeError):
        pass

    return file_path.name


def cmd_index():
    print(f"Indexing KORA Monorepo at {KORA_ROOT}...")

    catalog = {
        "_manifest": {
            "urn": "urn:kora:catalog:master:2.0.0",
            "federation": {"visibility": "public"},
            "description": "Auto-generated Kora Monorepo Catalog",
        },
        "Catalog": {
            "Agents": [],
            "Skills": [],
            "Knowledge": [],
            "Documents": [],
            "Other": [],
        },
    }

    count = 0
    extensions = {".yaml", ".yml", ".md"}

    for root, dirs, files in os.walk(KORA_ROOT):
        # Skip directories we don't care about
        dirs[:] = [d for d in dirs if d not in (".git", "scripts", "tests", "docs", "staging", ".claude", ".agent", ".venv", "__pycache__")]

        for file in files:
            file_path = Path(root) / file
            if file_path.suffix not in extensions:
                continue

            # Skip the catalog itself!
            if file_path.absolute() == CATALOG_PATH.absolute():
                continue

            doc, err = load_yaml_safe(file_path)
            if err:
                print(f"[WARN] Error parsing {file_path.relative_to(KORA_ROOT)}: {err}")
                continue

            if (
                doc
                and isinstance(doc, dict)
                and "_manifest" in doc
                and "urn" in doc["_manifest"]
            ):
                urn = doc["_manifest"]["urn"]
                title = get_artifact_title(doc, file_path)
                rel_path = str(file_path.relative_to(KORA_ROOT))

                entry = {
                    "urn": urn,
                    "title": title,
                    "file": rel_path,
                    "status": doc.get("status", doc.get("Status", "published")),
                }

                # urn:{ns}:{type}:{id}:{ver}
                parts = urn.split(":")
                obj_type = parts[2] if len(parts) >= 3 else "unknown"

                if obj_type == "agent":
                    catalog["Catalog"]["Agents"].append(entry)
                elif obj_type == "skill":
                    catalog["Catalog"]["Skills"].append(entry)
                elif obj_type in ("kb", "core", "domain"):
                    catalog["Catalog"]["Knowledge"].append(entry)
                elif obj_type in ("doc", "sys", "ref", "tool"):
                    catalog["Catalog"]["Documents"].append(entry)
                else:
                    catalog["Catalog"]["Other"].append(entry)

                count += 1

    # Save the catalog
    os.makedirs(CATALOG_PATH.parent, exist_ok=True)
    with open(CATALOG_PATH, "w", encoding="utf-8") as f:
        yaml.dump(
            catalog, f, sort_keys=False, allow_unicode=True, default_flow_style=False
        )

    print(
        f"Successfully indexed {count} artifacts into {CATALOG_PATH.relative_to(KORA_ROOT)}!"
    )


def cmd_resolve(urn):
    doc, _ = load_yaml_safe(CATALOG_PATH)
    if not doc or "Catalog" not in doc:
        print("Error: Catalog not found or invalid. Run 'kora index' first.")
        sys.exit(1)

    for category, items in doc["Catalog"].items():
        for item in items:
            # We can resolve exactly or by prefix
            if item.get("urn", "").startswith(urn):
                path = KORA_ROOT / item["file"]
                print(f"[{category}] {item['urn']} -> {path.absolute()}")
                return

    print(f"URN '{urn}' not found in catalog.")
    sys.exit(1)


def cmd_health():
    print("Checking Kora Monorepo Health (Broken links)...")
    doc, _ = load_yaml_safe(CATALOG_PATH)
    if not doc or "Catalog" not in doc:
        print("Error: Catalog not found or invalid. Run 'kora index' first.")
        sys.exit(1)

    # Get all known URNs from catalog
    known_urns = set()
    for category, items in doc["Catalog"].items():
        for item in items:
            known_urns.add(item.get("urn"))

    # Also add the catalog URN itself
    known_urns.add(doc["_manifest"]["urn"])

    broken_links = 0
    checked_files = 0

    # Match both tripartite KB URNs (urn:ns:kb:id) and 5-segment bootstrap URNs
    # (urn:ns:agent-bootstrap:name:version). The version segment is optional.
    urn_pattern = re.compile(
        r"(urn:[a-z0-9-]+:[a-z0-9-]+:[a-z0-9.-]+(?::[a-z0-9.-]+)?)"
    )

    for root, dirs, files in os.walk(KORA_ROOT):
        dirs[:] = [d for d in dirs if d not in (".git", "scripts", "tests", "docs", "staging", ".claude", ".agent", ".venv", "__pycache__")]
        for file in files:
            if not (
                file.endswith(".yml") or file.endswith(".yaml") or file.endswith(".md")
            ):
                continue

            file_path = Path(root) / file
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
            except Exception:
                continue

            # Collect URNs line-by-line, skipping fenced code blocks and "Incorrecto:" lines
            in_code_block = False
            valid_urns_in_file = set()
            for line in content.split("\n"):
                stripped = line.strip()
                if stripped.startswith("```"):
                    in_code_block = not in_code_block
                    continue
                if in_code_block:
                    continue
                # Skip lines that are pedagogical "incorrect" examples
                if stripped.lower().startswith("**incorrecto"):
                    continue
                for f_urn in urn_pattern.findall(line):
                    valid_urns_in_file.add(f_urn)
            for f_urn in valid_urns_in_file:
                if f_urn not in known_urns:
                    # Skip informal cross-agent references (urn:ns:agent:name)
                    # These are logical references not indexed as catalog entries
                    parts = f_urn.split(":")
                    if len(parts) == 4 and parts[2] == "agent":
                        continue
                    print(f"[BROKEN] In {file_path.relative_to(KORA_ROOT)}: {f_urn}")
                    broken_links += 1
            checked_files += 1

    # Also validate allowed_kb in agent config.json files against catalog
    import json
    config_broken = 0
    for root, dirs, files in os.walk(KORA_ROOT / "agents"):
        dirs[:] = [d for d in dirs if d not in (".git",)]
        for file in files:
            if file != "config.json":
                continue
            file_path = Path(root) / file
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    cfg = json.load(f)
                for kb_urn in cfg.get("allowed_kb", []):
                    if not isinstance(kb_urn, str) or not kb_urn.startswith("urn:"):
                        print(f"[CONFIG] In {file_path.relative_to(KORA_ROOT)}: non-URN entry '{kb_urn}'")
                        config_broken += 1
                    elif kb_urn not in known_urns:
                        print(f"[CONFIG] In {file_path.relative_to(KORA_ROOT)}: unknown KB URN '{kb_urn}'")
                        config_broken += 1
            except Exception as e:
                print(f"[WARN] Could not check {file_path.relative_to(KORA_ROOT)}: {e}")

    total_broken = broken_links + config_broken
    print(f"\nHealth check complete. Scanned {checked_files} files.")
    if total_broken == 0:
        print("All URN references are healthy!")
    else:
        if broken_links > 0:
            print(f"  {broken_links} broken URN reference(s) in file content.")
        if config_broken > 0:
            print(f"  {config_broken} broken/invalid URN(s) in agent config.json allowed_kb.")
        print(f"  Total: {total_broken} issue(s) found.")


def cmd_validate():
    print("Validating KORA agents against KORA 2.0 Schema...")
    try:
        import jsonschema
    except ImportError:
        print(
            "Error: 'jsonschema' module is required for validation. Run 'pip install jsonschema'."
        )
        sys.exit(1)

    schema, _ = load_yaml_safe(SCHEMA_PATH)
    if not schema:
        print(f"Error: Could not load schema from {SCHEMA_PATH}")
        sys.exit(1)

    doc, _ = load_yaml_safe(CATALOG_PATH)
    if not doc or "Catalog" not in doc:
        print("Error: Catalog not found. Run 'kora index' first.")
        sys.exit(1)

    agents = doc["Catalog"].get("Agents", [])
    valid_count = 0
    invalid_count = 0

    for agent in agents:
        agent_path = KORA_ROOT / agent["file"]
        agent_data, err = load_yaml_safe(agent_path)
        if not agent_data:
            print(
                f"[FAIL] Could not parse YAML: {agent_path.relative_to(KORA_ROOT)}. Error: {err}"
            )
            invalid_count += 1
            continue

        try:
            jsonschema.validate(instance=agent_data, schema=schema)
            # print(f"[OK] {agent_path.relative_to(KORA_ROOT)}")
            valid_count += 1
        except jsonschema.exceptions.ValidationError as e:
            print(f"[FAIL] {agent_path.relative_to(KORA_ROOT)} - {e.message}")
            invalid_count += 1

    print(f"Validation complete! Valid: {valid_count}, Invalid: {invalid_count}")


def cmd_stats():
    doc, _ = load_yaml_safe(CATALOG_PATH)
    if not doc or "Catalog" not in doc:
        print("Error: Catalog not found. Run 'kora index' first.")
        sys.exit(1)

    print("=== KORA Monorepo Stats ===")
    total = 0
    for category, items in doc["Catalog"].items():
        count = len(items)
        total += count
        if count > 0:
            print(f"  {category}: {count}")
    print(f"  TOTAL: {total}")

    # Count by namespace
    ns_counts = {}
    for category, items in doc["Catalog"].items():
        for item in items:
            urn = item.get("urn", "")
            parts = urn.split(":")
            ns = parts[1] if len(parts) >= 2 else "unknown"
            ns_counts[ns] = ns_counts.get(ns, 0) + 1

    print("\nBy namespace:")
    for ns, count in sorted(ns_counts.items(), key=lambda x: -x[1]):
        print(f"  {ns}: {count}")


def main():
    parser = argparse.ArgumentParser(description="KORA Monorepo CLI")
    subparsers = parser.add_subparsers(dest="command", help="Sub-commands")

    # Index
    p_index = subparsers.add_parser(
        "index", help="Rebuild the catalog from source artifacts"
    )

    # Resolve
    p_resolve = subparsers.add_parser(
        "resolve", help="Resolve a URN to a local file path"
    )
    p_resolve.add_argument("urn", help="The URN to resolve")

    # Health
    p_health = subparsers.add_parser(
        "health", help="Check for broken URNs across files"
    )

    # Validate
    p_validate = subparsers.add_parser(
        "validate", help="Validate agent YAMLs against the KORA schema"
    )

    # Stats
    p_stats = subparsers.add_parser(
        "stats", help="Show monorepo statistics from the catalog"
    )

    args = parser.parse_args()

    if args.command == "index":
        cmd_index()
    elif args.command == "resolve":
        cmd_resolve(args.urn)
    elif args.command == "health":
        cmd_health()
    elif args.command == "validate":
        cmd_validate()
    elif args.command == "stats":
        cmd_stats()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
